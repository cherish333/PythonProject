import tkinter as tk
from tkinter import filedialog
import json
import os
import subprocess
import windnd  #,æ›¿æ¢,tkinterdnd2
import winshell
from win32com.client import Dispatch
import re
from PIL import Image,ImageTk
import time
import logging
from datetime import datetime
import glob
import sys
import webbrowser
from urllib.parse import urlparse
import shutil
import gc

def _initialize_tkdnd():
    """åˆå§‹åŒ–æ‹–æ”¾åŠŸèƒ½""",
    root = tk.Tk()
    
    # ç”¨äºæ‹–æ”¾æ”¯æŒ,
    def _on_drop(files):
        for file in files:
            # åˆ›å»ºæ¨¡æ‹Ÿçš„äº‹ä»¶å¯¹è±¡
            class DndEvent:
                def __init__(self, data):
                    self.data = data
            
            event = DndEvent(file)
            app._on_drop(event)
    
    # ç»‘å®šæ‹–æ”¾äº‹ä»¶
    windnd.hook_dropfiles(root, func=_on_drop)
    
    return root

class DarkScrollbar(tk.Canvas):
    """è‡ªå®šä¹‰æ·±è‰²æ»šåŠ¨æ¡""",
    def __init__(self, parent, **kwargs):
        self.command = kwargs.pop('command', None)
        bg = kwargs.pop('bg', '#2b2b2b')
        width = kwargs.pop('width', 10)
        super().__init__(parent, width=width, bg=bg, highlightthickness=0, **kwargs)
        
        # åˆå§‹åŒ–å±æ€§
        self._offset = 0
        self._scroll_bar = None
    
        # åˆ›å»ºæ»šåŠ¨æ¡
        self._create_scroll_bar()
        
        # ç»‘å®šäº‹ä»¶
        self.bind('<Configure>', self._on_configure)
        self.bind('<Button-1>', self._on_click)
        self.bind('<B1-Motion>', self._on_drag)
    def _create_scroll_bar(self):
        """åˆ›å»ºæ»šåŠ¨æ¡"""
        if self._scroll_bar:
            self.delete(self._scroll_bar)
        height = self.winfo_height() - 2*self._offset
        if height > 0:
            # åˆ›å»ºåœ†è§’æ»šåŠ¨æ¡
            radius = 5  # åœ†è§’åŠå¾„
            x1, y1 = 2, self._offset
            x2, y2 = self.winfo_width()-2, height
            
            # åˆ›å»ºåœ†è§’çŸ©å½¢è·¯å¾„
            self._scroll_bar = self.create_polygon(
                x1+radius, y1,
                x2-radius, y1,
                x2, y1+radius,
                x2, y2-radius,
                x2-radius, y2,
                x1+radius, y2,  # ä¿®å¤è¿™é‡Œï¼šå°† x,+radius æ”¹ä¸º x1+radius
                x1, y2-radius,
                x1, y1+radius,
                fill='#4c5052',
                outline='#4c5052',
                smooth=True
            )
    
    def _on_configure(self, event):
        """!ç†å¤§å°æ”¹å˜äº‹ä»¶"""
        self._create_scroll_bar()
    
    def _on_click(self, event):
        """å¤„ç†ç‚¹å‡»äº‹ä»¶"""
        if self.command:
            fraction = event.y / self.winfo_height()
            self.command('moveto', fraction)
    def _on_drag(self, event):
        """å¤„ç†æ‹–åŠ¨äº‹ä»¶"""
        if self.command:
            fraction = event.y / self.winfo_height()
            self.command('moveto', fraction)
    
    def set(self, first, last):
        """è®¾ç½®æ»šåŠ¨æ¡ä½ç½®"""
        first = float(first)
        last = float(last)
        height = self.winfo_height()
        top = height * first
        bottom = height * last
        self._offset = top
        self._create_scroll_bar()
    def configure(self, **kwargs):
        """é…ç½®æ»šåŠ¨æ¡"""
        if 'command' in kwargs:
            self.command = kwargs.pop('command')
        super().configure(**kwargs)

class RoundedButton(tk.Frame):
    """åœ†è§’æŒ‰é’®"""
    def __init__(self, parent, text, command=None, **kwargs):
        super().__init__(parent, bg=kwargs.get('bg', '#2b2b2b'))
        
        # æå–æ ·å¼å‚æ•°
        bg_color = kwargs.get('bg', '#2b2b2b')
        fg_color = kwargs.get('fg', 'white')
        active_bg = kwargs.get('activebackground', bg_color)
        active_fg = kwargs.get('activeforeground', fg_color)
        width = kwargs.get('width', 10)  # å°†é»˜è®¤å®½åº¦ä» 20 æ”¹ä¸º 10
        height = kwargs.get('height', 2)
        font = kwargs.get('font', ('Microsoft YaHei', 9))
        
        # åˆ›å»ºåœ†è§’æ¡†æ¶
        self.frame = tk.Frame(
            self,
            bg=bg_color,
            highlightbackground=kwargs.get('highlightbackground', bg_color),
            highlightthickness=kwargs.get('highlightthickness', 1),
            bd=0
        )
        self.frame.pack(expand=True, fill="both", padx=2, pady=2)
        
        # åˆ›å»ºæŒ‰é’®
        self.button = tk.Button(
            self.frame,
            text=text,
            command=command,
            bg=bg_color,
            fg=fg_color,
            activebackground=active_bg,
            activeforeground=active_fg,
            relief="flat",
            cursor="hand2",
            width=width,
            height=height,
            font=font,
            bd=0
        )
        self.button.pack(expand=True, fill="both", padx=1, pady=1)
        
        # ç»‘å®šäº‹ä»¶
        self.button.bind('<Enter>', self._on_enter)
        self.button.bind('<Leave>', self._on_leave)
        
    def _on_enter(self, event):
        """é¼ æ ‡è¿›å…¥æ—¶çš„æ•ˆæœ"""
        self.frame.configure(highlightbackground=self.button.cget('activebackground'))
        
    def _on_leave(self, event):
        """é¼ æ ‡ç¦»å¼€æ—¶çš„æ•ˆæœ"""
        self.frame.configure(highlightbackground=self.button.cget('bg'))
        
    def configure(self, **kwargs):
        """é…ç½®æŒ‰é’®å±æ€§"""
        self.button.configure(**kwargs)
        if 'bg' in kwargs:
            self.frame.configure(bg=kwargs['bg'])
            
    def cget(self, key):
        """è·å–æŒ‰é’®å±æ€§"""
        return self.button.cget(key)

class FolderAccessTool:
    VERSION = "1.0.0"
    
    # æ‰©å±•æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
    SUPPORTED_FORMATS = {
        "å›¾ç‰‡": [
            ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", 
            ".ico", ".svg", ".raw", ".heic", ".psd", ".ai"
        ],
        "è§†é¢‘": [
            ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm",
            ".m4v", ".mpg", ".mpeg", ".3gp", ".rmvb", ".ts", ".vob"
        ],
        "éŸ³é¢‘": [
            ".mp3", ".wav", ".flac", ".m4a", ".aac", ".ogg", ".wma",
            ".mid", ".midi", ".ape", ".alac", ".aiff", ".opus"
        ],
        "æ–‡æ¡£": [
            ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
            ".txt", ".rtf", ".csv", ".xml", ".json", ".md", ".epub",
            ".mobi", ".azw3", ".djvu"
        ],
        "å‹ç¼©åŒ…": [
            ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz",
            ".iso", ".img", ".dmg", ".pkg"
        ],
        "ä»£ç ": [
            ".py", ".java", ".cpp", ".c", ".h", ".js", ".html", ".css",
            ".php", ".rb", ".go", ".rs", ".swift", ".kt", ".ts",
            ".sql", ".sh", ".bat", ".ps1"
        ],
        "å­—ä½“": [
            ".ttf", ".otf", ".woff", ".woff2", ".eot", ".fon"
        ],
        "3Dæ¨¡å‹": [
            ".obj", ".fbx", ".3ds", ".max", ".blend", ".dae",
            ".stl", ".ply", ".glb", ".gltf", ".usd", ".abc"
        ],
        "è®¾è®¡": [
            ".sketch", ".fig", ".xd", ".ai", ".eps", ".indd",
            ".dwg", ".dxf", ".skp",
            ".psd",     # Photoshop
            ".ai",      # Illustrator
            ".indd",    # InDesign
            ".xd",      # XD
            # 3D è®¾è®¡
            ".c4d",     # Cinema 4D
            ".ma",      # Maya ASCII
            ".mb",      # Maya Binary
            ".hip",     # Houdini
            ".hipnc",   # Houdini Non Commercial
            ".blend",   # Blender
            # å…¶ä»–è®¾è®¡è½¯ä»¶
            ".sketch",  # Sketch
            ".fig",     # Figma
            ".xcf",     # GIMP
            ".kra",     # Krita
            ".clip",    # Clip Studio Paint
            ".cdr",     # CorelDRAW
            # CAD
            ".dwg",     # AutoCAD
            ".dxf",     # AutoCAD Exchange
            ".skp",     # SketchUp
            # æè´¨å’Œè´´å›¾
            ".sbsar",   # Substance Designer
            ".sbs",     # Substance Source
        ],
        "å·¥ç¨‹æ–‡ä»¶": [
            # After Effects
            ".aep",     # After Effects å·¥ç¨‹æ–‡ä»¶
            ".aepx",    # After Effects XML å·¥ç¨‹æ–‡ä»¶
            # Premiere Pro
            ".prproj",  # Premiere Pro é¡¹ç›®
            # Final Cut Pro
            ".fcpx",    # Final Cut Pro X é¡¹ç›®
            ".fcpxml",  # Final Cut Pro XML
            # DaVinci Resolve
            ".drp",     # DaVinci Resolve
            ".drt",     # DaVinci Resolve æ¨¡æ¿
            # Vegas Pro
            ".veg",     # Vegas Pro é¡¹ç›®
            ".vf",      # Vegas Pro æ•ˆæœé¢„è®¾
            # ç‰¹æ•ˆæ¨¡æ¿
            ".mogrt",   # Motion Graphics Template
            # Unreal Engine
            ".uproject", # Unreal Engine å·¥ç¨‹æ–‡ä»¶
        ],
    }

    # æ·»åŠ æ–‡ä»¶ç±»å‹å¯¹åº”çš„å›¾æ ‡
    FILE_TYPE_ICONS = {
        "å›¾ç‰‡": "ğŸ–¼ï¸",
        "è§†é¢‘": "ğŸ¬",
        "éŸ³é¢‘": "ğŸµ",
        "æ–‡æ¡£": "ğŸ“„",
        "å‹ç¼©åŒ…": "ğŸ“¦",
        "ä»£ç ": "ğŸ’»",
        "å­—ä½“": "ğŸ“",
        "3Dæ¨¡å‹": "ğŸ®",
        "è®¾è®¡": "ğŸ¨",
        "å·¥ç¨‹æ–‡ä»¶": "ğŸ¬",  # æ”¹ç”¨è§†é¢‘ç¼–è¾‘å›¾æ ‡
    }
    
    # ä¿æŒåŸæœ‰çš„å­—ä½“è®¾ç½®
    FONT_FAMILY = "Microsoft YaHei"
    FONT_NORMAL = ("Microsoft YaHei", 9)
    FONT_BOLD = ("Microsoft YaHei", 11, "bold")
    FONT_TITLE = ("Microsoft YaHei", 10)
    
    # æ·»åŠ ç‰¹æ®Šè½¯ä»¶è·¯å¾„æœç´¢é…ç½®
    SPECIAL_SOFTWARE_PATHS = {
        "Logitech G HUB": {
            "name": "Logitech G HUB",
            "possible_paths": [
                "C:\\Program Files\\LGHUB\\lghub.exe",
                "C:\\Program Files (x86)\\LGHUB\\lghub.exe",
                os.path.expandvars("%LOCALAPPDATA%\\LGHUB\\lghub.exe")
            ],
            "icon": "ğŸ®"
        },
        "FastStone Capture": {
            "name": "FastStone Capture",
            "possible_paths": [
                "C:\\Program Files\\FastStone Capture\\FSCapture.exe",
                "C:\\Program Files (x86)\\FastStone Capture\\FSCapture.exe"
            ],
            "icon": "ğŸ“¸"
        },
        "Steam Games": {
            "name": "Steam Games",
            "possible_paths": [
                "C:\\Program Files (x86)\\Steam\\steamapps\\common",
                "C:\\Program Files\\Steam\\steamapps\\common",
                "D:\\Steam\\steamapps\\common",
                "E:\\Steam\\steamapps\\common"
            ],
            "icon": "ğŸ®"
        },
        "Epic Games": {
            "name": "Epic Games",
            "possible_paths": [
                "C:\\Program Files\\Epic Games",
                "C:\\Program Files (x86)\\Epic Games",
                "D:\\Epic Games",
                "E:\\Epic Games"
            ],
            "icon": "ğŸ®"
        }
    }
    
    # æ·»åŠ å›¾ç‰‡é¢„è§ˆçª—å£çš„é…ç½®
    IMAGE_PREVIEW_SIZE = (200, 200)  # é¢„è§ˆçª—å£å¤§å°
    
    # æ·»åŠ æŒ‰é’®æ ·å¼åˆ°ç±»å±æ€§
    BUTTON_STYLES = {
        "folder": {
            "bg": "#4c5052",
            "active_bg": "#5c6062",
            "icon": "ğŸ“"
        },
        "program": {
            "bg": "#2d4052",
            "active_bg": "#3d5062",
            "icon": "ğŸ’»"
        },
        "video": {
            "bg": "#3d524c",
            "active_bg": "#4d625c",
            "icon": "ğŸ–¼"  # ä¿®æ”¹è§†é¢‘å›¾æ ‡
        },
        "image": {
            "bg": "#3d524c",
            "active_bg": "#4d625c",
            "icon": "ğŸ–¼"  # ç»Ÿä¸€å›¾ç‰‡å›¾æ ‡
        },
        "document": {
            "bg": "#4c4d52",
            "active_bg": "#5c5d62",
            "icon": "ğŸ“„"
        },
        "web": {  # ä¿®æ”¹ç½‘é¡µæŒ‰é’®æ ·å¼
            "bg": "#524c52",  # ç´«è‰²ç³»
            "active_bg": "#625c62",
            "icon": "ğŸŒ"
        },
        "project": {
            "bg": "#2d4052",
            "active_bg": "#3d5062",
            "icon": "ğŸ¬"  # æ”¹ç”¨è§†é¢‘ç¼–è¾‘å›¾æ ‡
        },
        "design": {  # æ·»åŠ è®¾è®¡æ–‡ä»¶çš„æ ·å¼
            "bg": "#524C52",
            "active_bg": "#625C62",
            "icon": "ğŸ¨"
        },
    }
    
    def __init__(self):
        # æ·»åŠ å®‰å…¨æ€§æ£€æŸ¥
        self._verify_environment()
        
        self.root = _initialize_tkdnd()
        self.root.title("QuickLaunch")
        
        # åœ¨ç±»åˆå§‹åŒ–æ—¶å®šä¹‰é…ç½®æ–‡ä»¶è·¯å¾„
        self.config_dir = os.path.join(os.getenv('APPDATA'), 'FolderQuickAccess')
        self.config_file = os.path.join(self.config_dir, 'paths.json')
        
        # ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
        
        # åŠ è½½ä¿å­˜çš„è·¯å¾„
        self.paths_data = self._load_paths()
        
        # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        window_width = 500
        window_height = 730
        
        # è®¡ç®—çª—å£ä½ç½®
        x = 20
        y = 20
        
        # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
        self.root.geometry(f"{window_width}x{window_height}+{x}+{y}")
        self.root.configure(bg="#2b2b2b")
        
        # è®¾ç½®çª—å£æœ€å°å’Œæœ€å¤§å°ºå¯¸
        self.root.minsize(400, 500)
        self.root.maxsize(800, screen_height - 100)
        
        # å…ˆéšè—çª—å£
        self.root.withdraw()
        
        # ä¿®æ”¹å›¾æ ‡è·¯å¾„
        # è·å–ç¨‹åºè¿è¡Œè·¯å¾„
        if getattr(sys, 'frozen', False):
            # å¦‚æœæ˜¯æ‰“åŒ…åçš„exe
            application_path = os.path.dirname(sys.executable)
        else:
            # å¦‚æœæ˜¯ç›´æ¥è¿è¡Œçš„pyæ–‡ä»¶
            application_path = os.path.dirname(os.path.abspath(__file__))
        
        # è®¾ç½®å›¾æ ‡è·¯å¾„
        self.icon_path = os.path.join(application_path, "czp.ico")
        
        # åªåœ¨å›¾æ ‡æ–‡ä»¶å­˜åœ¨æ—¶æ‰è®¾ç½®å›¾æ ‡
        if os.path.exists(self.icon_path):
            try:
                self.root.iconbitmap(self.icon_path)
                self.root.tk.call('wm', 'iconbitmap', self.root._w, self.icon_path)
                print(f"å›¾æ ‡è®¾ç½®æˆåŠŸ: {self.icon_path}")
            except Exception as e:
                print(f"è®¾ç½®å›¾æ ‡å¤±è´¥: {e}")
                self.icon_path = None
        else:
            print(f"è­¦å‘Š: å›¾æ ‡æ–‡ä»¶ä¸å­˜åœ¨: {self.icon_path}")
            self.icon_path = None
        
        # ä¿®æ”¹çª—å£æ ·å¼è®¾ç½®
        if os.name == 'nt':  # Windowsç³»ç»Ÿ
            try:
                from ctypes import windll
                GWL_STYLE = -16
                WS_MINIMIZEBOX = 0x00020000
                style = windll.user32.GetWindowLongW(self.root.winfo_id(), GWL_STYLE)
                style |= WS_MINIMIZEBOX
                windll.user32.SetWindowLongW(self.root.winfo_id(), GWL_STYLE, style)
            except:
                pass
        
        self.add_dialog = None  # ç”¨äºå­˜å‚¨æ·»åŠ è·¯å¾„çš„å¯¹è¯æ¡†
        
        # å±…ä¸­çª—å£
        self._center_window()
        
        # ç§»é™¤è‡ªå®šä¹‰æ ‡é¢˜æ çš„åˆ›å»º
        # self._create_title_bar()
        
        # åˆ›å»ºä¸»æ¡†æ¶
        self.main_frame = tk.Frame(self.root, bg="#2b2b2b")
        self.main_frame.pack(padx=20, pady=20, fill="both", expand=True)
        
        # åˆ›å»ºæŒ‰é’®æ˜¾ç¤ºåŒºåŸŸçš„å®¹å™¨æ¡†æ¶
        buttons_container = tk.Frame(self.main_frame, bg="#2b2b2b")
        buttons_container.pack(fill="both", expand=True, pady=(0, 10))
        
        # åˆ›å»ºç”»å¸ƒå’Œæ»šåŠ¨æ¡
        self.canvas = tk.Canvas(buttons_container, bg="#2b2b2b", highlightthickness=0)
        scrollbar = DarkScrollbar(buttons_container, width=10)
        scrollbar.configure(command=self.canvas.yview)
        
        # åˆ›å»ºæŒ‰é’®æ˜¾ç¤ºåŒºåŸŸ
        self.buttons_frame = tk.Frame(self.canvas, bg="#2b2b2b")
        
        # é…ç½®ç”»å¸ƒ
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        # æ‰“åŒ…æ»šåŠ¨æ¡å’Œç”»å¸ƒ
        scrollbar.pack(side="right", fill="y")
        self.canvas.pack(side="left", fill="both", expand=True)
        
        # åœ¨ç”»å¸ƒä¸Šåˆ›å»ºçª—å£
        self.canvas_frame = self.canvas.create_window((0, 0), window=self.buttons_frame, anchor="nw")
        
        # æ·»åŠ å¤åˆ¶è·¯å¾„é€‰é¡¹çš„çŠ¶æ€å˜é‡
        self.copy_path_enabled = tk.BooleanVar(value=False)
        
        # æ·»åŠ ç½®é¡¶çŠ¶æ€å˜é‡
        self.is_topmost = tk.BooleanVar(value=False)
        
        # æ·»åŠ ä¸´æ—¶ç¬”è®°çŠ¶æ€å˜é‡
        self.note_enabled = tk.BooleanVar(value=False)
        
        # åˆ›å»ºå·¥å…·æ ï¼ˆæ”¾åœ¨ä¸‹æ–¹ï¼‰
        self._create_toolbar()
        
        # æ·»åŠ çª—å£å¤§å°è°ƒæ•´åŒºåŸŸ
        self._create_resize_area()
        
        # ç¡®ä¿çª—å£å°ºå¯¸å·²æ›´æ–°
        self.root.update_idletasks()
        
        # åˆ›å»ºæŒ‰é’®
        self._create_path_buttons()
        
        # å†æ¬¡å¼ºåˆ¶æ›´æ–°æ‰€æœ‰æ§ä»¶çš„å¸ƒå±€
        self.root.update_idletasks()
        self.main_frame.update_idletasks()
        self.buttons_frame.update_idletasks()
        self.canvas.update_idletasks()
        
        # ç¡®ä¿ç”»å¸ƒå®½åº¦æ­£ç¡®
        self.canvas.itemconfig(self.canvas_frame, width=self.canvas.winfo_width())
        
        # æ˜¾ç¤ºçª—å£
        self.root.deiconify()
        
        # å»¶è¿Ÿä¸€ä¸ªçŸ­æš‚æ—¶é—´åå†æ¬¡æ›´æ–°å¸ƒå±€
        self.root.after(100, self._delayed_layout_update)
        
        # ç»‘å®šäº‹ä»¶
        self.buttons_frame.bind("<Configure>", self._on_frame_configure)
        self.canvas.bind("<Configure>", self._on_canvas_configure)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # ç»‘å®šæ•´ä¸ªçª—å£çš„æ‹–åŠ¨
        self._bind_window_move(self.root)
        
        # åœ¨åŸæœ‰çš„åˆå§‹åŒ–ä»£ç åæ·»åŠ 
        self.preview_window = None
        
        # åœ¨åŸæœ‰çš„åˆå§‹åŒ–ä»£ç åæ·»åŠ 
        self.hot_corner_active = False
        self.hot_corner_size = 5  # çƒ­åŒºå¤§å°ï¼ˆåƒç´ ï¼‰
        self.check_interval = 100  # æ£€æŸ¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
        
        # åˆ›å»ºçƒ­åŒºæ£€æµ‹å™¨ï¼ˆç¡®ä¿å§‹ç»ˆç½®é¡¶ï¼‰
        self._create_hot_corner_detector()
        
        # ç»‘å®šæœ€å°åŒ–äº‹ä»¶
        self.root.bind("<Unmap>", self._on_minimize)
        self.root.bind("<Map>", self._on_restore)
        
        # è®¾ç½®æ—¥å¿—ç³»ç»Ÿ
        self._setup_logging()
        
        # æ·»åŠ ç¼“å­˜æœºåˆ¶
        self._icon_cache = {}
        self._path_info_cache = {}
        
        # è®¾ç½®å¿«æ·é”®ï¼ˆåªä¿ç•™å¿…è¦çš„å¿«æ·é”®ï¼‰
        self._setup_hotkeys()
        
        # æ·»åŠ çª—å£ä½ç½®è·Ÿè¸ª
        self._last_window_pos = (self.root.winfo_x(), self.root.winfo_y())
        self._last_window_size = (self.root.winfo_width(), self.root.winfo_height())
        
        # ä¿®æ”¹çª—å£å¤§å°å˜åŒ–çš„äº‹ä»¶ç»‘å®š
        self.root.bind('<Configure>', self._on_window_configure)
        
        # æ·»åŠ å‰ªè´´æ¿ç›‘å¬
        self.root.bind_all('<Control-v>', self._handle_paste)  # ä½¿ç”¨ bind_all è€Œä¸æ˜¯ bind
        
        # æ·»åŠ ç¬”è®°æ–‡ä»¶è·¯å¾„
        self.notes_file = os.path.join(self.config_dir, 'notes.txt')
        
        
        # åŠ è½½ä¿å­˜çš„ç¬”è®°
        self._load_notes()
        
        # æ·»åŠ æ¸…ç†è®¡æ—¶å™¨
        self._cleanup_timer = None
        self._setup_cleanup_timer()
        
        # æ·»åŠ æ‹–æ‹½æ’åºç›¸å…³çš„å±æ€§
        self.drag_source = None
        self.drag_target = None
        self.drag_indicator = None
        
        # æ·»åŠ æ¶ˆæ¯æç¤ºç›¸å…³å±æ€§
        self.msg_window = None
        self.msg_timer = None
    def _setup_cleanup_timer(self):
        """è®¾ç½®å®šæœŸæ¸…ç†å®šæ—¶å™¨"""
        if self._cleanup_timer:
            self.root.after_cancel(self._cleanup_timer)
        
        self._cleanup_memory()
        self._cleanup_timer = self.root.after(300000, self._setup_cleanup_timer)  # æ¯5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
    def _cleanup_memory(self):
        """æ¸…ç†å†…å­˜"""
        # æ¸…ç†å›¾æ ‡ç¼“å­˜
        if hasattr(self, '_icon_cache'):
            self._icon_cache.clear()
        
        # æ¸…ç†è·¯å¾„ä¿¡æ¯ç¼“å­˜
        if hasattr(self, '_path_info_cache'):
            self._path_info_cache.clear()
        
        # å¼ºåˆ¶åƒåœ¾å›æ”¶
        gc.collect()
    def _verify_environment(self):
        """éªŒè¯è¿è¡Œç¯å¢ƒ"""
        try:
            # æ·»åŠ æ›´å¤šçš„å®‰å…¨æ€§æ£€æŸ¥
            if not os.name == 'nt':
                raise SystemError("ä»…æ”¯æŒWindowsç³»ç»Ÿ")
            
            # æ£€æŸ¥å¿…è¦çš„ç³»ç»Ÿç›®å½•æ˜¯å¦å­˜åœ¨
            system_dirs = [
                os.environ.get('SYSTEMROOT'),
                os.environ.get('PROGRAMFILES'),
                os.environ.get('APPDATA'),
                os.environ.get('LOCALAPPDATA')  # æ·»åŠ æœ¬åœ°åº”ç”¨æ•°æ®ç›®å½•æ£€æŸ¥
            ]
            
            if not all(system_dirs):
                raise SystemError("ç³»ç»Ÿç¯å¢ƒå¼‚å¸¸")
            
            # æ£€æŸ¥é…ç½®ç›®å½•æƒé™
            config_dir = os.path.join(os.environ.get('APPDATA'), 'FolderQuickAccess')
            if not os.path.exists(config_dir):
                try:
                    os.makedirs(config_dir)
                except:
                    raise PermissionError("æ— æ³•åˆ›å»ºé…ç½®ç›®å½•")
            
            # æ£€æŸ¥å†™å…¥æƒé™
            test_path = os.path.join(config_dir, 'test.txt')
            try:
                with open(test_path, 'w') as f:
                    f.write('test')
                os.remove(test_path)
            except:
                raise PermissionError("ç¼ºå°‘å¿…è¦çš„æ–‡ä»¶è®¿é—®æƒé™")
                
            # æ£€æŸ¥ä¸´æ—¶ç›®å½•è®¿é—®æƒé™
            temp_dir = os.environ.get('TEMP')
            if not (temp_dir and os.access(temp_dir, os.W_OK)):
                raise PermissionError("æ— æ³•è®¿é—®ä¸´æ—¶ç›®å½•")
                
        except Exception as e:
            logging.error(f"ç¯å¢ƒéªŒè¯å¤±è´¥: {e}")
            self._show_message(f"ç¯å¢ƒæ£€æŸ¥å¤±è´¥: {str(e)}")
            sys.exit(1)
    def _setup_logging(self):
        """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
        log_dir = os.path.join(self.config_dir, 'logs')
        os.makedirs(log_dir, exist_ok=True)
        
        log_file = os.path.join(log_dir, f'quicklaunch_{datetime.now().strftime("%Y%m%d")}.log')
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
    def _center_window(self):
        """å°†çª—å£ä½ç½®è°ƒæ•´åˆ°å±å¹•å·¦ä¸Šè§’"""
        # ä¿®æ”¹è¿™é‡Œçš„çª—å£å°ºå¯¸
        window_width = 500    # ä» 560 æ”¹ä¸º 530 (-30)
        window_height = 730   # ä¿æŒé«˜åº¦ä¸å˜
        
        # è®¾ç½®ä½ç½®ï¼šé è¿‘å·¦ä¸Šè§’ï¼Œä½†ç•™å‡ºä¸€ç‚¹è¾¹è·
        x = 20  # è·ç¦»å·¦è¾¹ç¼˜20åƒç´ 
        y = 20  # è·ç¦»ä¸Šè¾¹ç¼˜20åƒç´ 
        
        # è®¾ç½®çª—å£ä½ç½®å’Œå¤§å°
        self.root.geometry(f"{window_width}x{window_height}+{x}+{y}")
        
        # è®¾ç½®çª—å£æœ€å°å°ºå¯¸
        self.root.minsize(400, 500)
    def _bind_window_move(self, widget):
        """ç»‘å®šçª—å£æ‹–åŠ¨äº‹ä»¶åˆ°æŒ‡å®šwidget"""
        def start_move(event):
            # å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ã€èœå•æˆ–æ–‡æœ¬æ¡†ï¼Œä¸å¯åŠ¨çª—å£ç§»åŠ¨
            if (isinstance(event.widget, (tk.Button, tk.Menu, tk.Text)) or 
                hasattr(event.widget, 'master') and isinstance(event.widget.master, RoundedButton)):
                return
            
            # ä¿å­˜åˆå§‹ä½ç½®
            widget._drag_start_x = event.x
            widget._drag_start_y = event.y
            
        def do_move(event):
            # å¦‚æœæ²¡æœ‰å¼€å§‹æ‹–åŠ¨æˆ–ç‚¹å‡»çš„æ˜¯æŒ‰é’®ã€èœå•æˆ–æ–‡æœ¬æ¡†ï¼Œä¸å¤„ç†
            if (not hasattr(widget, '_drag_start_x') or 
                isinstance(event.widget, (tk.Button, tk.Menu, tk.Text)) or 
                hasattr(event.widget, 'master') and isinstance(event.widget.master, RoundedButton)):
                return
            
            # è®¡ç®—ä½ç§»
            dx = event.x - widget._drag_start_x
            dy = event.y - widget._drag_start_y
            
            # è·å–çª—å£å½“å‰ä½ç½®
            x = self.root.winfo_x() + dx
            y = self.root.winfo_y() + dy
            
            # ç¡®ä¿çª—å£ä¸ä¼šç§»å‡ºå±å¹•
            screen_width = self.root.winfo_screenwidth()
            screen_height = self.root.winfo_screenheight()
            window_width = self.root.winfo_width()
            window_height = self.root.winfo_height()
            
            # é™åˆ¶çª—å£ä½ç½®
            x = max(0, min(x, screen_width - window_width))
            y = max(0, min(y, screen_height - window_height))
            
            # ç§»åŠ¨çª—å£
            self.root.geometry(f"+{x}+{y}")
            
        def stop_move(event):
            # æ¸…é™¤æ‹–åŠ¨çŠ¶æ€
            if hasattr(widget, '_drag_start_x'):
                del widget._drag_start_x
                del widget._drag_start_y
        
        # ç»‘å®šäº‹ä»¶
        widget.bind('<Button-1>', start_move)
        widget.bind('<B1-Motion>', do_move)
        widget.bind('<ButtonRelease-1>', stop_move)
        
        # ä¸ºæ‰€æœ‰å­ç»„ä»¶ä¹Ÿç»‘å®šè¿™äº›äº‹ä»¶ï¼Œä½†æ’é™¤æ–‡æœ¬æ¡†
        for child in widget.winfo_children():
            if not isinstance(child, (tk.Button, tk.Menu, tk.Text)):
                child.bind('<Button-1>', start_move)
                child.bind('<B1-Motion>', do_move)
                child.bind('<ButtonRelease-1>', stop_move)
    def _create_toolbar(self):
        """åˆ›å»ºå·¥å…·æ """
        # åˆ›å»ºå·¥å…·æ ï¼ˆæ”¾åœ¨æœ€ä¸‹æ–¹ï¼‰
        toolbar = tk.Frame(self.main_frame, bg="#2b2b2b")
        toolbar.pack(side="bottom", fill="x", pady=(0, 0))
        
        # åˆ›å»ºç¬”è®°åŒºåŸŸå®¹å™¨
        self.note_container = tk.Frame(toolbar, bg="#2b2b2b")
        self.note_container.pack_propagate(False)  # é˜²æ­¢è‡ªåŠ¨è°ƒæ•´å¤§å°
        
        # åˆ›å»ºè¾“å…¥æ¡†
        self.temp_input = tk.Text(
            self.note_container,
            bg="#1e1e1e",
            fg="white",
            insertbackground="white",
            relief="flat",
            font=self.FONT_NORMAL,
            height=3,
            width=1,
            wrap=tk.WORD
        )
        self.temp_input.pack(fill="both", expand=True, padx=5, pady=3)
        
        # æ·»åŠ æ–°çš„ç²˜è´´äº‹ä»¶å¤„ç†
        def handle_note_paste(event):
            # åªæœ‰å½“ç¬”è®°åŠŸèƒ½å¯ç”¨æ—¶æ‰å¤„ç†ç²˜è´´
            if self.note_enabled.get():
                return None  # å…è®¸é»˜è®¤ç²˜è´´è¡Œä¸º
            return "break"  # é˜»æ­¢ç²˜è´´åˆ°ç¬”è®°
        
        self.temp_input.bind('<Control-v>', handle_note_paste)
        
        # æ·»åŠ è‡ªåŠ¨ä¿å­˜åŠŸèƒ½
        def auto_save(event=None):
            if self.note_enabled.get():
                self._save_notes()
        
        # ç»‘å®šæŒ‰é”®äº‹ä»¶å’Œå¤±å»ç„¦ç‚¹äº‹ä»¶æ¥è§¦å‘ä¿å­˜
        self.temp_input.bind('<KeyRelease>', auto_save)
        self.temp_input.bind('<FocusOut>', auto_save)
        
        # æ·»åŠ æç¤ºæ–‡æœ¬
        self.temp_input.insert("1.0", "ä¸´æ—¶ç¬”è®°...")
        self.temp_input.config(fg='gray')
        
        # ä¿®æ”¹ç„¦ç‚¹äº‹ä»¶å¤„ç†
        def on_focus_in(event):
            if self.temp_input.get("1.0", "end-1c").strip() == "ä¸´æ—¶ç¬”è®°...":
                self.temp_input.delete("1.0", tk.END)
                self.temp_input.config(fg='white')
        
        def on_focus_out(event):
            current_text = self.temp_input.get("1.0", "end-1c").strip()
            if not current_text:
                self.temp_input.delete("1.0", tk.END)
                self.temp_input.insert("1.0", "ä¸´æ—¶ç¬”è®°...")
                self.temp_input.config(fg='gray')
            else:
                self._save_notes()  # å¤±å»ç„¦ç‚¹æ—¶ä¿å­˜
        
        # ç»‘å®šäº‹ä»¶
        self.temp_input.bind('<FocusIn>', on_focus_in)
        self.temp_input.bind('<FocusOut>', on_focus_out)
        
        # åˆ›å»ºæŒ‰é’®å®¹å™¨
        button_container = tk.Frame(toolbar, bg="#2b2b2b", height=40)
        button_container.pack(side="bottom", fill="x", pady=5)
        button_container.pack_propagate(False)
        
        buttons_frame = tk.Frame(button_container, bg="#2b2b2b")
        buttons_frame.pack(expand=True)
        
        # æ·»åŠ æ¸…ç©ºæŒ‰é’®
        clear_btn = RoundedButton(
            buttons_frame,
            text="æ¸…ç©º",
            command=self._clear_all_shortcuts,
            bg="#B85959",
            fg="white",
            activebackground="#C86666",
            activeforeground="white",
            relief="flat",
            cursor="hand2",
            font=self.FONT_NORMAL,
            width=4,  # å¢åŠ å®½åº¦ä»2åˆ°4
            height=1
        )
        clear_btn.pack(side="left", padx=5)
        
        # æ·»åŠ å¤åˆ¶è·¯å¾„é€‰é¡¹
        copy_checkbox = tk.Checkbutton(
            buttons_frame,
            text="è·¯å¾„å¤åˆ¶",  # å°† "Copy Path" æ”¹ä¸º "è·¯å¾„å¤åˆ¶"
            variable=self.copy_path_enabled,
            bg="#2b2b2b",
            fg="white",
            selectcolor="#2b2b2b",
            activebackground="#2b2b2b",
            activeforeground="white",
            font=self.FONT_NORMAL
        )
        copy_checkbox.pack(side="left", padx=10)
        
        # æ·»åŠ ç½®é¡¶é€‰é¡¹
        topmost_checkbox = tk.Checkbutton(
            buttons_frame,
            text="ç½®é¡¶",
            variable=self.is_topmost,
            command=self._toggle_topmost,
            bg="#2b2b2b",
            fg="white",
            selectcolor="#2b2b2b",
            activebackground="#2b2b2b",
            activeforeground="white",
            font=self.FONT_NORMAL
        )
        topmost_checkbox.pack(side="left", padx=10)
        
        # æ·»åŠ ä¸´æ—¶ç¬”è®°é€‰é¡¹
        note_checkbox = tk.Checkbutton(
            buttons_frame,
            text="ç¬”è®°",
            variable=self.note_enabled,
            command=self._toggle_note,
            bg="#2b2b2b",
            fg="white",
            selectcolor="#2b2b2b",
            activebackground="#2b2b2b",
            activeforeground="white",
            font=self.FONT_NORMAL
        )
        note_checkbox.pack(side="left", padx=10)
        
        # åœ¨æŒ‰é’®å®¹å™¨ä¸­æ·»åŠ æ’åºæŒ‰é’®ï¼ˆåœ¨æ¸…ç©ºæŒ‰é’®æ—è¾¹ï¼‰
        sort_btn = RoundedButton(
            buttons_frame,
            text="æ’åº",
            command=self._show_sort_dialog,
            bg="#4c5052",
            fg="white",
            activebackground="#5c6062",
            activeforeground="white",
            relief="flat",
            cursor="hand2",
            font=self.FONT_NORMAL,
            width=4,  # å¢åŠ å®½åº¦ä»2åˆ°4
            height=1
        )
        sort_btn.pack(side="left", padx=5)
    def _clear_all_shortcuts(self):
        """æ¸…ç©ºæ‰€æœ‰å¿«æ·æ–¹å¼"""
        try:
            # åˆ›å»ºç¡®è®¤å¯¹è¯æ¡†
            confirm_window = tk.Toplevel(self.root)
            confirm_window.title("ç¡®è®¤æ¸…ç©º")
            confirm_window.configure(bg="#2b2b2b")
            confirm_window.transient(self.root)
            
            # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
            window_width = 300
            window_height = 120
            x = self.root.winfo_x() + (self.root.winfo_width() - window_width) // 2
            y = self.root.winfo_y() + (self.root.winfo_height() - window_height) // 2
            confirm_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # æ·»åŠ è­¦å‘Šæ–‡æœ¬
            warning_label = tk.Label(
                confirm_window,
                text="ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å¿«æ·æ–¹å¼å—ï¼Ÿ\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼",
                bg="#2b2b2b",
                fg="#E81123",
                font=self.FONT_BOLD
            )
            warning_label.pack(pady=10)
            
            # åˆ›å»ºæŒ‰é’®å®¹å™¨
            btn_frame = tk.Frame(confirm_window, bg="#2b2b2b")
            btn_frame.pack(pady=10)
            
            # ç¡®è®¤æŒ‰é’®
            def confirm_clear():
                self.paths_data = {}  # æ¸…ç©ºæ•°æ®
                self._save_paths()    # ä¿å­˜ç©ºæ•°æ®
                self._create_path_buttons()  # åˆ·æ–°ç•Œé¢
                confirm_window.destroy()
                self._show_message("å·²æ¸…ç©ºæ‰€æœ‰å¿«æ·æ–¹å¼!")
            
            confirm_btn = tk.Button(
                btn_frame,
                text="ç¡®è®¤æ¸…ç©º",
                command=confirm_clear,
                bg="#E81123",
                fg="white",
                activebackground="#FF1A1A",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL
            )
            confirm_btn.pack(side="left", padx=10)
            
            # å–æ¶ˆæŒ‰é’®
            cancel_btn = tk.Button(
                btn_frame,
                text="å–æ¶ˆ",
                command=confirm_window.destroy,
                bg="#4c5052",
                fg="white",
                activebackground="#5c6062",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL
            )
            cancel_btn.pack(side="left", padx=10)
            
            # è®¾ç½®ç„¦ç‚¹å¹¶ä½¿çª—å£ç½®é¡¶
            confirm_window.focus_set()
            confirm_window.grab_set()
            
        except Exception as e:
            print(f"Error in clear shortcuts: {e}")
            self._show_message("æ¸…ç©ºå¤±è´¥!")
    def _show_add_dialog(self):
        """æ˜¾ç¤ºæ·»åŠ è·¯å¾„å¯¹è¯æ¡†"""
        if self.add_dialog:
            return
            
        self.add_dialog = tk.Toplevel(self.root)
        self.add_dialog.title("Add Path")
        self.add_dialog.geometry("300x200")
        self.add_dialog.configure(bg="#2b2b2b")
        self.add_dialog.transient(self.root)
        
        # å¯¹è¯æ¡†å†…å®¹æ¡†æ¶
        dialog_frame = tk.Frame(self.add_dialog, bg="#2b2b2b")
        dialog_frame.pack(padx=20, pady=20, fill="both", expand=True)
        
        # è·¯å¾„è¾“å…¥æ¡†
        path_label = tk.Label(
            dialog_frame,
            text="Path:",
            bg="#2b2b2b",
            fg="white",
            font=self.FONT_TITLE
        )
        path_label.pack(anchor="w")
        
        path_entry = tk.Entry(
            dialog_frame,
            bg="#1e1e1e",
            fg="white",
            insertbackground="white",
            relief="flat",
            highlightbackground="#1e1e1e",
            highlightcolor="#4c5052",
            highlightthickness=1
        )
        path_entry.pack(fill="x", pady=(0, 10))
        
        # æŒ‰é’®åç§°è¾“å…¥æ¡†
        name_label = tk.Label(
            dialog_frame,
            text="Button Name:",
            bg="#2b2b2b",
            fg="white",
            font=self.FONT_TITLE
        )
        name_label.pack(anchor="w")
        
        name_entry = tk.Entry(
            dialog_frame,
            bg="#1e1e1e",
            fg="white",
            insertbackground="white",
            relief="flat",
            highlightbackground="#1e1e1e",
            highlightcolor="#4c5052",
            highlightthickness=1
        )
        name_entry.pack(fill="x", pady=(0, 10))
        
        # æŒ‰é’®æ¡†æ¶
        btn_frame = tk.Frame(dialog_frame, bg="#2b2b2b")
        btn_frame.pack(fill="x", pady=(10, 0))
        
        # æµè§ˆæŒ‰é’®
        browse_btn = tk.Button(
            btn_frame,
            text="Browse",
            command=lambda: self._browse_path(path_entry),
            bg="#4c5052",
            fg="white",
            activebackground="#5c6062",
            activeforeground="white",
            relief="flat",
            cursor="hand2",
            font=self.FONT_NORMAL
        )
        browse_btn.pack(side="left", padx=5)
        
        # ç¡®è®¤æŒ‰é’®
        confirm_btn = tk.Button(
            btn_frame,
            text="Add",
            command=lambda: self._confirm_add(path_entry.get(), name_entry.get()),
            bg="#4c5052",
            fg="white",
            activebackground="#5c6062",
            activeforeground="white",
            relief="flat",
            cursor="hand2",
            font=self.FONT_NORMAL
        )
        confirm_btn.pack(side="left", padx=5)
        
        def on_dialog_close():
            self.add_dialog.destroy()
            self.add_dialog = None
            
        self.add_dialog.protocol("WM_DELETE_WINDOW", on_dialog_close)
        self.add_dialog.grab_set()
    def _create_path_buttons(self):
        """åˆ›å»ºè·¯å¾„æŒ‰é’®"""
        try:
            # æ¸…é™¤ç°æœ‰æŒ‰é’®
            for widget in self.buttons_frame.winfo_children():
                widget.destroy()
            
            # å¦‚æœæ²¡æœ‰ä»»ä½•æŒ‰é’®ï¼Œæ˜¾ç¤ºè½¯ä»¶è¯´æ˜
            if not self.paths_data:
                # åˆ›å»ºè¯´æ˜æ–‡æœ¬æ¡†æ¶
                guide_frame = tk.Frame(self.buttons_frame, bg="#2b2b2b")
                guide_frame.pack(expand=True, fill="both", padx=20, pady=20)
                
                # è½¯ä»¶è¯´æ˜æ–‡æœ¬
                guide_text = '''æ¬¢è¿ä½¿ç”¨ QuickLaunch å¿«é€Ÿå¯åŠ¨å·¥å…·

ä½¿ç”¨æ–¹æ³•ï¼š
â€¢ æ‹–æ”¾æ–‡ä»¶å¤¹ã€ç¨‹åºã€å¿«æ·æ–¹å¼åˆ°çª—å£å³å¯æ·»åŠ 
â€¢ å³é”®ç‚¹å‡»æŒ‰é’®å¯ä»¥åˆ é™¤æˆ–é‡å‘½å
â€¢ ç‚¹å‡»æŒ‰é’®ç›´æ¥æ‰“å¼€å¯¹åº”é¡¹ç›®

æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼š
â€¢ è§†é¢‘ç¼–è¾‘ï¼š AEã€PRã€è¾¾èŠ¬å¥‡ç­‰é¡¹ç›®æ–‡ä»¶
â€¢ 3Dè®¾è®¡ï¼šUEã€Mayaã€Houdiniã€C4Dã€Blender é¡¹ç›®æ–‡ä»¶
â€¢ 2Dè®¾è®¡ï¼šPSã€AIã€XDã€Sketchã€ç­‰è®¾è®¡æ–‡ä»¶
â€¢ å¸¸ç”¨æ–‡ä»¶ï¼šå›¾ç‰‡ã€è§†é¢‘ã€éŸ³é¢‘ã€æ–‡æ¡£ã€å‹ç¼©åŒ…ç­‰
â€¢ å¼€å‘ç›¸å…³ï¼š3Dæ¨¡å‹æ–‡ä»¶ã€ä»£ç æ–‡ä»¶ã€å­—ä½“æ–‡ä»¶

å¿«æ·æ“ä½œï¼š
â€¢ Ctrl+Vï¼šç²˜è´´ç½‘å€æ·»åŠ ç½‘é¡µå¿«æ·æ–¹å¼
â€¢ Escï¼šæœ€å°åŒ–åˆ°å·¦ä¸Šè§’
â€¢ æœ€å°åŒ–åç‚¹å‡»å±å¹•æœ€å·¦ä¸Šè§’å¯å¿«é€Ÿå‘¼å‡ºè½¯ä»¶
â€¢ å‹¾é€‰"è·¯å¾„å¤åˆ¶"å¯å¤åˆ¶è·¯å¾„è€Œä¸æ˜¯æ‰“å¼€
â€¢ å‹¾é€‰"ç½®é¡¶"å¯ä»¥è®©çª—å£ä¿æŒåœ¨æœ€ä¸Šå±‚
â€¢ å‹¾é€‰"ç¬”è®°"å¯ä»¥æ˜¾ç¤ºä¸´æ—¶è®°äº‹æœ¬

è‡ªå®šä¹‰åŠŸèƒ½ï¼š
â€¢ å³é”®èœå•ä¸­å¯é€‰æ‹©å¤šç§é¢„è®¾é¢œè‰²
â€¢ æ‹–åŠ¨æŒ‰é’®å¯ä»¥è‡ªç”±è°ƒæ•´é¡ºåº
â€¢ çª—å£å¤§å°å¯ä»¥è‡ªç”±è°ƒæ•´
â€¢ æ”¯æŒå¤šåˆ—è‡ªåŠ¨å¸ƒå±€

ğŸ’¡ æç¤ºï¼šæ‹–æ”¾ä»»ä½•æ–‡ä»¶åˆ°æ­¤å¤„å¼€å§‹ä½¿ç”¨'''
                
                # åˆ›å»ºæ–‡æœ¬æ ‡ç­¾
                guide_label = tk.Label(
                    guide_frame,
                    text=guide_text,
                    justify=tk.LEFT,
                    bg="#2b2b2b",
                    fg="#666666",  # ä½¿ç”¨æš—ç°è‰²
                    font=("Microsoft YaHei", 10),
                    padx=10,
                    pady=10
                )
                guide_label.pack(expand=True, fill="both")
                return
            
            # åˆ›å»ºç½‘æ ¼å¸ƒå±€æ¡†æ¶
            grid_frame = tk.Frame(self.buttons_frame, bg="#2b2b2b")
            grid_frame.pack(expand=True, fill="both", padx=5)
            
            # å¼ºåˆ¶æ›´æ–°ä»¥è·å–æ­£ç¡®çš„å®½åº¦
            self.root.update_idletasks()
            self.buttons_frame.update_idletasks()
            grid_frame.update_idletasks()
            
            # è·å–å®é™…å¯ç”¨å®½åº¦
            available_width = self.buttons_frame.winfo_width() - 10  # å‡å»å·¦å³è¾¹è·
            
            # æ ¹æ®çª—å£å®½åº¦ç¡®å®šåˆ—æ•°å’ŒæŒ‰é’®å®½åº¦
            if available_width >= 450:  # ä¸‰åˆ—çš„é˜ˆå€¼
                buttons_per_row = 3
                button_width = max(8, (available_width - 20) // (3 * 8))  # åŠ¨æ€è®¡ç®—æŒ‰é’®å®½åº¦
                padding = 3
            elif available_width >= 300:  # ä¸¤åˆ—çš„é˜ˆå€¼
                buttons_per_row = 2
                button_width = max(10, (available_width - 15) // (2 * 8))  # åŠ¨æ€è®¡ç®—æŒ‰é’®å®½åº¦
                padding = 4
            else:  # å•åˆ—
                buttons_per_row = 1
                button_width = max(15, (available_width - 10) // 8)  # åŠ¨æ€è®¡ç®—æŒ‰é’®å®½åº¦
                padding = 5
            
            # ç¡®ä¿æŒ‰é’®èƒ½å¤Ÿå¡«æ»¡æ•´è¡Œ
            total_buttons = len(self.paths_data)
            if total_buttons <= buttons_per_row:
                # å¦‚æœæŒ‰é’®æ•°é‡å°äºç­‰äºæ¯è¡ŒæŒ‰é’®æ•°ï¼Œè°ƒæ•´ä¸ºå¹³å‡åˆ†å¸ƒ
                buttons_per_row = total_buttons
                button_width = max(10, (available_width - (buttons_per_row + 1) * padding * 2) // (buttons_per_row * 8))
            
            # é…ç½®ç½‘æ ¼åˆ—çš„æƒé‡ï¼Œä½¿æŒ‰é’®å¹³å‡åˆ†å¸ƒ
            for i in range(buttons_per_row):
                grid_frame.grid_columnconfigure(i, weight=1)
            
            # åˆ›å»ºæŒ‰é’®æ—¶ä½¿ç”¨è®¡ç®—å‡ºçš„å®½åº¦
            for index, (name, path) in enumerate(self.paths_data.items()):
                try:
                    row = index // buttons_per_row
                    col = index % buttons_per_row
                    
                    # åˆ›å»ºæŒ‰é’®æ¡†æ¶
                    button_frame = tk.Frame(grid_frame, bg="#2b2b2b")
                    button_frame.grid(row=row, column=col, padx=padding, pady=padding, sticky="nsew")
                    
                    # å­˜å‚¨æŒ‰é’®ä¿¡æ¯ç”¨äºæ’åº
                    button_frame.path_name = name
                    button_frame.path_data = path
                    
                    # ä»åç§°ä¸­ç§»é™¤ä»»ä½•å·²å­˜åœ¨çš„å›¾æ ‡å’Œå‰ç¼€
                    clean_name = name
                    for icon in self.FILE_TYPE_ICONS.values():
                        clean_name = clean_name.replace(icon, '').strip()
                    # ç§»é™¤å·²å­˜åœ¨çš„ AE: å’Œ UE: å‰ç¼€
                    clean_name = re.sub(r'^(AE|UE):\s*', '', clean_name)
                    
                    # ç¡®å®šæŒ‰é’®ç±»å‹å’Œæ ·å¼
                    if path.startswith("web:"):
                        style = self.BUTTON_STYLES["web"]
                    elif path.startswith("program:"):
                        style = self.BUTTON_STYLES["program"]
                    elif path.startswith("file:"):
                        file_info = json.loads(path[5:])
                        if file_info['type'] == "å·¥ç¨‹æ–‡ä»¶":
                            style = self.BUTTON_STYLES["project"]
                            # æ ¹æ®æ‰©å±•åæ·»åŠ ç‰¹å®šæ ‡è¯†ï¼ˆåªåœ¨è¿™é‡Œæ·»åŠ ä¸€æ¬¡å‰ç¼€ï¼‰
                            if file_info['path'].lower().endswith('.aep'):
                                clean_name = f"AE: {clean_name}"
                            elif file_info['path'].lower().endswith('.uproject'):
                                clean_name = f"UE: {clean_name}"
                        elif file_info['type'] == "è§†é¢‘":
                            style = self.BUTTON_STYLES["video"]
                        elif file_info['type'] == "å›¾ç‰‡":
                            style = self.BUTTON_STYLES["image"]
                        else:
                            style = self.BUTTON_STYLES["document"]
                    else:
                        style = self.BUTTON_STYLES["folder"]
                    
                    # è·å–è‡ªå®šä¹‰é¢œè‰²
                    custom_colors = None
                    if isinstance(path, str):
                        if path.startswith(('program:', 'file:', 'web:')):
                            try:
                                data = json.loads(path.split(':', 1)[1])
                                custom_colors = data.get('colors')
                            except:
                                pass
                        elif path.startswith('folder:'):
                            try:
                                data = json.loads(path.split(':', 1)[1])
                                custom_colors = data.get('colors')
                            except:
                                pass
                        else:
                            # æ£€æŸ¥æ˜¯å¦æ˜¯ç›´æ¥çš„æ–‡ä»¶å¤¹è·¯å¾„
                            try:
                                if os.path.exists(path):
                                    custom_colors = None
                            except:
                                pass

                    # ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²æˆ–é»˜è®¤æ ·å¼
                    button_bg = custom_colors['bg'] if custom_colors else style["bg"]
                    button_active_bg = custom_colors['active_bg'] if custom_colors else style["active_bg"]

                    # åˆ›å»ºæŒ‰é’®æ—¶ä½¿ç”¨å¯¹åº”çš„é¢œè‰²
                    btn = RoundedButton(
                        button_frame,
                        text=f"{style['icon']} {clean_name}",
                        command=lambda p=path: self._on_button_click(p),
                        bg=button_bg,  # ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²
                        fg="white",
                        activebackground=button_active_bg,  # ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²
                        activeforeground="white",
                        relief="flat",
                        cursor="hand2",
                        width=button_width,  # ä½¿ç”¨è®¡ç®—å‡ºçš„å®½åº¦
                        height=2,
                        font=self.FONT_BOLD
                    )
                    btn.pack(fill="both", expand=True)
                    
                    # åˆ›å»ºå³é”®èœå•
                    menu = tk.Menu(
                        btn, 
                        tearoff=0, 
                        bg="#2b2b2b", 
                        fg="white",
                        activebackground="#4c5052", 
                        activeforeground="white",
                        font=self.FONT_NORMAL
                    )
                    
                    # æ·»åŠ é‡å‘½åé€‰é¡¹
                    menu.add_command(
                        label="é‡å‘½å",
                        command=lambda n=name: self._show_rename_dialog(n),
                        font=self.FONT_NORMAL
                    )
                    
                    # æ·»åŠ é¢œè‰²é€‰æ‹©å­èœå•
                    color_menu = tk.Menu(
                        menu,
                        tearoff=0,
                        bg="#2b2b2b",
                        fg="white",
                        activebackground="#4c5052",
                        activeforeground="white",
                        font=self.FONT_NORMAL
                    )
                    
                    # ä¿®æ”¹é¢œè‰²å®šä¹‰éƒ¨åˆ†
                    colors = {
                        "é»˜è®¤": {"bg": style["bg"], "active_bg": style["active_bg"]},
                        "è“è‰²": {"bg": "#2d4052", "active_bg": "#3d5062"},
                        "æ·±è“": {"bg": "#1a2733", "active_bg": "#2a3743"},
                        "å¤©è“": {"bg": "#2d5275", "active_bg": "#3d6285"},
                        "ç»¿è‰²": {"bg": "#3d524c", "active_bg": "#4d625c"},
                        "æ·±ç»¿": {"bg": "#2a3d38", "active_bg": "#3a4d48"},
                        "é’ç»¿": {"bg": "#2d5252", "active_bg": "#3d6262"},
                        "çº¢è‰²": {"bg": "#803333", "active_bg": "#994040"},
                        "æ·±çº¢": {"bg": "#662424", "active_bg": "#803030"},
                        "ç²‰çº¢": {"bg": "#804d5f", "active_bg": "#955d70"},
                        "ç´«è‰²": {"bg": "#524c52", "active_bg": "#625c62"},
                        "æ·±ç´«": {"bg": "#3d384d", "active_bg": "#4d485d"},
                        "æµ…ç´«": {"bg": "#4a4d66", "active_bg": "#5a5d76"},
                        "æ©™è‰²": {"bg": "#805c3d", "active_bg": "#956c4d"},
                        # ä¿®æ”¹é‡‘è‰²çš„é¢œè‰²å€¼
                        "é‡‘è‰²": {"bg": "#806633", "active_bg": "#997733"}  # è°ƒæ•´ä¸ºæ›´æ˜æ˜¾çš„é‡‘è‰²
                    }
                    
                    # æ·»åŠ é¢œè‰²é€‰é¡¹åˆ°å­èœå•
                    for color_name, color_values in colors.items():
                        color_menu.add_command(
                            label=color_name,
                            command=lambda n=name, c=color_values: self._change_button_color(n, c),
                            font=self.FONT_NORMAL,
                            background=color_values["bg"],  # è®¾ç½®èœå•é¡¹çš„èƒŒæ™¯è‰²
                            foreground="white",  # è®¾ç½®æ–‡å­—é¢œè‰²ä¸ºç™½è‰²
                            activebackground=color_values["active_bg"],  # è®¾ç½®é¼ æ ‡æ‚¬åœæ—¶çš„èƒŒæ™¯è‰²
                            activeforeground="white"  # è®¾ç½®é¼ æ ‡æ‚¬åœæ—¶çš„æ–‡å­—é¢œè‰²
                        )
                    
                    # å°†é¢œè‰²å­èœå•æ·»åŠ åˆ°ä¸»èœå•
                    menu.add_cascade(label="æ›´æ”¹é¢œè‰²", menu=color_menu)
                    menu.add_separator()  # æ·»åŠ åˆ†éš”çº¿
                    
                    # æ·»åŠ åˆ é™¤é€‰é¡¹
                    menu.add_command(
                        label="åˆ é™¤",
                        command=lambda n=name: self.root.after(100, lambda: self._delete_path(n)),
                        font=self.FONT_NORMAL
                    )
                    
                    # ç»‘å®šå³é”®èœå•
                    def show_menu(event, m=menu):
                        try:
                            m.post(event.x_root, event.y_root)
                        except Exception as e:
                            print(f"Show menu error: {e}")
                    
                    btn.bind("<Button-3>", show_menu)
                    btn.button.bind("<Button-3>", show_menu)
                    
                    # ä¿®æ”¹æ‹–æ‹½äº‹ä»¶ç»‘å®š
                    btn.button.bind('<Button-1>', lambda e, bf=button_frame: self._start_drag(e, bf))
                    btn.button.bind('<B1-Motion>', self._on_drag)
                    btn.button.bind('<ButtonRelease-1>', self._end_drag)
                    
                    # å°†æŒ‰é’®å¯¹è±¡ä¿å­˜åˆ°æ¡†æ¶ä¸­
                    button_frame.button = btn
                    
                except Exception as e:
                    print(f"Error creating button {index}: {e}")
                    continue
            
            # å¼ºåˆ¶æ›´æ–°å¸ƒå±€
            grid_frame.update_idletasks()
            self.buttons_frame.update_idletasks()
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            
        except Exception as e:
            print(f"Error in _create_path_buttons: {e}")
            raise
    def _start_drag(self, event, button_frame):
        """å¼€å§‹æ‹–æ‹½"""
        # æ£€æŸ¥æ˜¯å¦æŒ‰ä½äº†å³é”®ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¼€å§‹æ‹–æ‹½
        if event.num == 3:  # å³é”®ç‚¹å‡»
            return
        
        # ä¿å­˜æ‹–æ‹½æºå’Œåˆå§‹ä½ç½®
        self.drag_source = button_frame
        self.drag_start_pos = (event.x_root, event.y_root)
        
        # åˆ›å»ºæ‹–æ‹½æŒ‡ç¤ºå™¨
        if self.drag_indicator:
            self.drag_indicator.destroy()
        self.drag_indicator = tk.Frame(self.buttons_frame, bg="#4c5052", height=2)
        
        # é«˜äº®æ˜¾ç¤ºè¢«æ‹–æ‹½çš„æŒ‰é’®
        button_frame.configure(bg="#4c5052")

    def _on_drag(self, event):
        """æ‹–æ‹½è¿‡ç¨‹ä¸­"""
        if not self.drag_source or not hasattr(event, 'widget'):
            return
        
        # è·å–å½“å‰é¼ æ ‡ä½ç½®ä¸‹çš„éƒ¨ä»¶
        target = event.widget.winfo_containing(event.x_root, event.y_root)
        
        # å‘ä¸ŠæŸ¥æ‰¾ç›´åˆ°æ‰¾åˆ°æŒ‰é’®æ¡†æ¶
        while target and not hasattr(target, 'path_name'):
            target = target.master
        
        if target and hasattr(target, 'path_name') and target != self.drag_source:
            self.drag_target = target
            
            # æ›´æ–°æŒ‡ç¤ºå™¨ä½ç½®
            try:
                target_y = target.winfo_y() + target.winfo_height()
                self.drag_indicator.place(
                    x=target.winfo_x(),
                    y=target_y,
                    width=target.winfo_width()
                )
                self.drag_indicator.lift()  # ç¡®ä¿æŒ‡ç¤ºå™¨åœ¨æœ€ä¸Šå±‚
            except Exception as e:
                print(f"æ›´æ–°æŒ‡ç¤ºå™¨ä½ç½®å¤±è´¥: {e}")

    def _end_drag(self, event):
        """ç»“æŸæ‹–æ‹½"""
        try:
            if self.drag_source:
                # æ¢å¤æ‹–æ‹½æºçš„èƒŒæ™¯è‰²
                self.drag_source.configure(bg="#2b2b2b")
                
                if self.drag_target and self.drag_source != self.drag_target:
                    # è·å–æºå’Œç›®æ ‡çš„ç´¢å¼•
                    source_name = self.drag_source.path_name
                    target_name = self.drag_target.path_name
                    
                    # é‡æ–°æ’åº
                    self._reorder_buttons(source_name, target_name)
        except Exception as e:
            print(f"ç»“æŸæ‹–æ‹½æ—¶å‡ºé”™: {e}")
        finally:
            # æ¸…ç†
            if self.drag_indicator:
                self.drag_indicator.destroy()
                self.drag_indicator = None
            
            self.drag_source = None
            self.drag_target = None

    def _reorder_buttons(self, source_name, target_name):
        """é‡æ–°æ’åºæŒ‰é’®"""
        try:
            # è·å–æ‰€æœ‰æŒ‰é’®çš„é¡ºåº
            items = list(self.paths_data.items())
            source_idx = next(i for i, (name, _) in enumerate(items) if name == source_name)
            target_idx = next(i for i, (name, _) in enumerate(items) if name == target_name)
            
            # ç§»åŠ¨é¡¹ç›®
            item = items.pop(source_idx)
            items.insert(target_idx if target_idx > source_idx else target_idx, item)
            
            # æ›´æ–°æ•°æ®
            self.paths_data = dict(items)
            
            # ä¿å­˜æ–°çš„é¡ºåº
            self._save_paths()
            
            # é‡æ–°åˆ›å»ºæŒ‰é’®
            self._create_path_buttons()
            
            # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            self._show_message("æ’åºå®Œæˆ!")
            
        except Exception as e:
            print(f"é‡æ–°æ’åºå¤±è´¥: {e}")
            self._show_message("æ’åºå¤±è´¥!", important=True)  # é”™è¯¯ä¿¡æ¯æ˜¾ç¤ºçª—å£
    def _swap_buttons(self, button1, button2):
        """äº¤æ¢ä¸¤ä¸ªæŒ‰é’®çš„ä½ç½®"""
        idx1 = list(self.paths_data.keys()).index(button1.path_name)
        idx2 = list(self.paths_data.keys()).index(button2.path_name)
        
        if idx1 != idx2:
            keys = list(self.paths_data.keys())
            keys[idx1], keys[idx2] = keys[idx2], keys[idx1]
            
            new_paths_data = {}
            for key in keys:
                new_paths_data[key] = self.paths_data[key]
            
            self.paths_data = new_paths_data
            self._create_path_buttons()
    def _open_path(self, path):
        """æ‰“å¼€æ–‡ä»¶å¤¹"""
        try:
            # ç¡®ä¿è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„
            abs_path = os.path.abspath(path)
            print(f"å°è¯•æ‰“å¼€è·¯å¾„: {abs_path}")
            
            if os.path.exists(abs_path):
                if os.path.isdir(abs_path):
                    # ä½¿ç”¨ç»å¯¹è·¯å¾„æ‰“å¼€æ–‡ä»¶å¤¹ï¼Œç§»é™¤ check=True
                    subprocess.run(['explorer', abs_path])
                    return True  # è¡¨ç¤ºæˆåŠŸæ‰“å¼€
                else:
                    print(f"è·¯å¾„ä¸æ˜¯æ–‡ä»¶å¤¹: {abs_path}")
                    self._show_message("æ— æ•ˆçš„æ–‡ä»¶å¤¹è·¯å¾„!")
            else:
                print(f"è·¯å¾„ä¸å­˜åœ¨: {abs_path}")
                self._show_message("è·¯å¾„ä¸å­˜åœ¨!")
                
        except Exception as e:
            print(f"æ‰“å¼€æ–‡ä»¶å¤¹é”™è¯¯: {e}")
            # åªæœ‰åœ¨çœŸæ­£å‡ºé”™æ—¶æ‰æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
            if not os.path.exists(abs_path) or not os.path.isdir(abs_path):
                self._show_message("æ— æ³•æ‰“å¼€æ–‡ä»¶å¤¹!")
    def _delete_path(self, name):
        """åˆ é™¤è·¯å¾„"""
        try:
            if name in self.paths_data:
                # ç¦ç”¨æ‰€æœ‰æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
                for widget in self.buttons_frame.winfo_children():
                    for child in widget.winfo_children():
                        if isinstance(child, RoundedButton):
                            child.configure(state='disabled')
                
                # åˆ é™¤è·¯å¾„æ•°æ®
                del self.paths_data[name]
                self._save_paths()
                
                # ç›´æ¥é‡å»ºæŒ‰é’®
                self._create_path_buttons()
                
                # æ›´æ–°ç”»å¸ƒ
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
                
                # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                self.root.after(100, lambda: self._show_message("å·²åˆ é™¤!", important=True))  # åˆ é™¤æ“ä½œæ˜¾ç¤ºçª—å£
                
        except Exception as e:
            print(f"Delete path error: {e}")
            self._show_message("åˆ é™¤å¤±è´¥!", important=True)  # é”™è¯¯ä¿¡æ¯æ˜¾ç¤ºçª—å£
            # å‘ç”Ÿé”™è¯¯æ—¶é‡æ–°åŠ è½½æ‰€æœ‰æŒ‰é’®
            try:
                self._create_path_buttons()
            except:
                pass
    def _load_paths(self):
        """åŠ è½½ä¿å­˜çš„è·¯å¾„"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    paths = json.load(f)
                    return paths if paths else {}
            return {}
        except Exception as e:
            print(f"Error loading paths: {e}")
            return {}
            
    def _save_paths(self):
        """ä¿å­˜è·¯å¾„é…ç½®å¹¶åˆ›å»ºå¤‡ä»½"""
        try:
            # å…ˆåˆ›å»ºä¸´æ—¶æ–‡ä»¶
            temp_file = self.config_file + '.tmp'
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(self.paths_data, f, ensure_ascii=False, indent=4)
            
            # å¦‚æœåŸé…ç½®æ–‡ä»¶å­˜åœ¨ï¼Œåˆ›å»ºå¤‡ä»½
            if os.path.exists(self.config_file):
                backup_dir = os.path.join(self.config_dir, 'backups')
                os.makedirs(backup_dir, exist_ok=True)
                
                # åˆ›å»ºå¸¦æ—¶é—´æˆ³çš„å¤‡ä»½
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_file = os.path.join(
                    backup_dir, 
                    f'paths_backup_{timestamp}.json'
                )
                
                # å¤åˆ¶å½“å‰é…ç½®åˆ°å¤‡ä»½
                shutil.copy2(self.config_file, backup_file)
            
            # ç”¨ä¸´æ—¶æ–‡ä»¶æ›¿æ¢åŸé…ç½®æ–‡ä»¶
            if os.path.exists(temp_file):
                shutil.move(temp_file, self.config_file)
            
            # æ¸…ç†æ—§å¤‡ä»½ï¼ˆåªä¿ç•™æœ€è¿‘10ä¸ªï¼‰
            self._clean_old_backups()
                
        except Exception as e:
            logging.error(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
            self._show_message("é…ç½®ä¿å­˜å¤±è´¥ï¼")
            
            # å¦‚æœå­˜åœ¨ä¸´æ—¶æ–‡ä»¶ï¼Œåˆ é™¤å®ƒ
            if os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                except:
                    pass
    def _clean_old_backups(self):
        backups = sorted(glob.glob(os.path.join(self.config_dir, 'backups', 'paths_backup_*.json')))
        if len(backups) > 10:
            for old_backup in backups[:-10]:
                os.remove(old_backup)
    def _show_message(self, message, important=False):
        """æ˜¾ç¤ºæ¶ˆæ¯æç¤º
        Args:
            message: æ¶ˆæ¯å†…å®¹
            important: æ˜¯å¦æ˜¯é‡è¦æ¶ˆæ¯ï¼Œåªæœ‰é‡è¦æ¶ˆæ¯æ‰ä¼šæ˜¾ç¤ºçª—å£
        """
        try:
            # å¦‚æœä¸æ˜¯é‡è¦æ¶ˆæ¯ï¼Œåªæ‰“å°åˆ°æ§åˆ¶å°
            if not important:
                print(f"æ“ä½œæç¤º: {message}")
                return
                
            if not self.root.winfo_exists():
                return
            
            # å¦‚æœå·²æœ‰æ¶ˆæ¯çª—å£ï¼Œå…ˆæ¸…ç†
            if self.msg_window and self.msg_window.winfo_exists():
                self.msg_window.destroy()
            if self.msg_timer:
                self.root.after_cancel(self.msg_timer)
            
            # åˆ›å»ºæ–°çš„æ¶ˆæ¯çª—å£
            self.msg_window = tk.Toplevel(self.root)
            self.msg_window.iconbitmap(self.icon_path)
            self.msg_window.overrideredirect(True)
            self.msg_window.configure(bg="#1e1e1e")
            self.msg_window.attributes('-topmost', True, '-alpha', 0.0)
            
            # ç¡®ä¿æ¶ˆæ¯çª—å£åœ¨å±å¹•èŒƒå›´å†…
            window_width = 200
            window_height = 60
            screen_width = self.root.winfo_screenwidth()
            screen_height = self.root.winfo_screenheight()
            
            x = min(
                self.root.winfo_x() + (self.root.winfo_width() - window_width) // 2,
                screen_width - window_width
            )
            y = min(
                self.root.winfo_y() + (self.root.winfo_height() - window_height) // 2,
                screen_height - window_height
            )
            
            x = max(0, x)
            y = max(0, y)
            
            msg_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # åˆ›å»ºå¸¦è¾¹æ¡†çš„æ¡†æ¶
            frame = tk.Frame(
                msg_window,
                bg="#1e1e1e",
                highlightbackground="#4c5052",
                highlightthickness=1
            )
            frame.pack(fill="both", expand=True, padx=2, pady=2)
            
            # æ·»åŠ æ¶ˆæ¯
            msg_label = tk.Label(
                frame,
                text=message,
                bg="#1e1e1e",
                fg="white",
                font=self.FONT_TITLE
            )
            msg_label.pack(pady=15)
            
            # æ·¡å…¥åŠ¨ç”»è®¡æ•°å™¨
            fade_in_counter = [0]
            
            def fade_in_step():
                """å•æ­¥æ·¡å…¥"""
                if not msg_window.winfo_exists():
                    return
                
                fade_in_counter[0] += 1
                msg_window.attributes('-alpha', fade_in_counter[0] / 10)
                
                if fade_in_counter[0] < 10:
                    msg_window.after(20, fade_in_step)
                else:
                    # æ·¡å…¥å®Œæˆåç­‰å¾…ä¸€æ®µæ—¶é—´å†æ·¡å‡º
                    msg_window.after(800, start_fade_out)
            
            def start_fade_out():
                """å¼€å§‹æ·¡å‡ºåŠ¨ç”»"""
                if not msg_window.winfo_exists():
                    return
                fade_out_counter = [10]
                
                def fade_out_step():
                    """å•æ­¥æ·¡å‡º"""
                    if not msg_window.winfo_exists():
                        return
                    
                    fade_out_counter[0] -= 1
                    msg_window.attributes('-alpha', fade_out_counter[0] / 10)
                    
                    if fade_out_counter[0] > 0:
                        msg_window.after(20, fade_out_step)
                    else:
                        msg_window.destroy()
                
                fade_out_step()
            
            # å¯åŠ¨æ·¡å…¥åŠ¨ç”»
            fade_in_step()
        except Exception as e:
            print(f"æ˜¾ç¤ºæ¶ˆæ¯å¤±è´¥: {e}")
    def _browse_path(self, entry):
        """æµè§ˆæ–‡ä»¶å¤¹"""
        path = filedialog.askdirectory()
        if path:
            entry.delete(0, tk.END)
            entry.insert(0, path)
    def _confirm_add(self, path, name):
        """ç¡®è®¤æ·»åŠ è·¯å¾„"""
        if path and name:
            self.paths_data[name] = path
            self._save_paths()
            self._create_path_buttons()
            self.add_dialog.destroy()
            self.add_dialog = None
            self._show_message("Path added successfully!")
        
    def _on_frame_configure(self, event=None):
        """æ›´æ–°ç”»å¸ƒçš„æ»šåŠ¨åŒºåŸŸ"""
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
    def _on_canvas_configure(self, event):
        """å½“ç”»å¸ƒå¤§å°æ”¹å˜æ—¶ï¼Œè°ƒæ•´å†…éƒ¨æ¡†æ¶çš„å®½åº¦"""
        self.canvas.itemconfig(self.canvas_frame, width=event.width)
    def _on_mousewheel(self, event):
        """å¤„ç†é¼ æ ‡æ»šè½®äº‹ä»¶"""
        if self.canvas.winfo_height() < self.buttons_frame.winfo_height():
            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
    def _create_resize_area(self):
        """åˆ›å»ºçª—å£å¤§å°è°ƒæ•´åŒºåŸŸ"""
        resize_frame = tk.Frame(self.root, bg="#1e1e1e", height=4, cursor="sizing")
        resize_frame.pack(side="bottom", fill="x")
        
        def start_resize(event):
            self.root.start_y = event.y_root
            self.root.start_x = event.x_root
            self.root.start_height = self.root.winfo_height()
            self.root.start_width = self.root.winfo_width()
        
        def do_resize(event):
            if not hasattr(self.root, 'start_height'):
                return
            
            # è®¡ç®—é«˜åº¦å’Œå®½åº¦çš„å˜åŒ–
            height_diff = event.y_root - self.root.start_y
            width_diff = event.x_root - self.root.start_x
            
            # è®¡ç®—æ–°çš„é«˜åº¦å’Œå®½åº¦
            new_height = self.root.start_height + height_diff
            new_width = self.root.start_width + width_diff
            
            # è·å–æœ€å°å’Œæœ€å¤§å°ºå¯¸
            min_width = 120  # ä¸minsizeä¿æŒä¸€è‡´
            min_height = 300
            max_width = 800
            max_height = self.root.winfo_screenheight() - 100
            
            # åº”ç”¨é™åˆ¶
            new_width = max(min_width, min(new_width, max_width))
            new_height = max(min_height, min(new_height, max_height))
            
            # ç¡®ä¿çª—å£ä¸ä¼šè¶…å‡ºå±å¹•è¾¹ç•Œ
            x = max(0, min(self.root.winfo_x(), self.root.winfo_screenwidth() - new_width))
            y = max(0, min(self.root.winfo_y(), self.root.winfo_screenheight() - new_height))
            
            # æ›´æ–°çª—å£å¤§å°å’Œä½ç½®
            self.root.geometry(f"{int(new_width)}x{int(new_height)}+{x}+{y}")
            
            # å¼ºåˆ¶æ›´æ–°æŒ‰é’®å¸ƒå±€
            self.root.after(10, self._create_path_buttons)
        
        def stop_resize(event):
            if hasattr(self.root, 'start_height'):
                delattr(self.root, 'start_height')
                delattr(self.root, 'start_width')
                delattr(self.root, 'start_x')
                delattr(self.root, 'start_y')
        
        resize_frame.bind("<Button-1>", start_resize)
        resize_frame.bind("<B1-Motion>", do_resize)
        resize_frame.bind("<ButtonRelease-1>", stop_resize)
        
        # æ·»åŠ è§†è§‰åé¦ˆ
        def on_enter(event):
            resize_frame.configure(bg="#4c5052")
        
        def on_leave(event):
            resize_frame.configure(bg="#1e1e1e")
        
        resize_frame.bind("<Enter>", on_enter)
        resize_frame.bind("<Leave>", on_leave)
    def _redraw_interface(self):
        """é‡ç»˜æ•´ä¸ªç•Œé¢"""
        try:
            # æ›´æ–°ç”»å¸ƒé…ç½®
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            
            # é‡æ–°è®¡ç®—å’Œæ›´æ–°æŒ‰é’®æ¡†æ¶çš„å®½åº¦
            self.canvas.itemconfig(self.canvas_frame, width=self.canvas.winfo_width())
            
            # å¼ºåˆ¶æ›´æ–°æ‰€æœ‰å­ç»„ä»¶
            for widget in self.buttons_frame.winfo_children():
                widget.update()
            
            # æ›´æ–°ä¸»çª—å£
            self.root.update_idletasks()
            self.root.update()
            
        except Exception as e:
            print(f"é‡ç»˜ç•Œé¢æ—¶å‡ºé”™: {e}")
    def _on_drop(self, event):
        """å¤„ç†æ–‡ä»¶å¤¹ã€å¿«æ·æ–¹å¼å’Œæ–‡ä»¶çš„æ‹–æ”¾"""
        try:
            # è·å–è·¯å¾„å¹¶å¤„ç†ç¼–ç 
            path = event.data
            if isinstance(path, bytes):
                path = path.decode('gbk')  # Windows é»˜è®¤ä½¿ç”¨ GBK ç¼–ç 
            
            # ç§»é™¤å¯èƒ½çš„èŠ±æ‹¬å·
            if path.startswith('{'):
                path = path[1:]
            if path.endswith('}'):
                path = path[:-1]
            
            # å¤„ç†å¿«æ·æ–¹å¼
            if path.lower().endswith('.lnk'):
                print(f"Getting info for: {path}")
                try:
                    shell = Dispatch("WScript.Shell")
                    shortcut = shell.CreateShortCut(path)
                    target_path = shortcut.Targetpath
                    
                    # æ£€æŸ¥æ˜¯å¦æ˜¯Adobeè½¯ä»¶
                    is_adobe = any(x in target_path.lower() for x in ['adobe', 'after effects', 'photoshop', 'premiere'])
                    
                    if is_adobe:
                        # å¯¹äºAdobeè½¯ä»¶ï¼Œç›´æ¥ä½¿ç”¨ç›®æ ‡è·¯å¾„
                        program_path = target_path
                        name = os.path.splitext(os.path.basename(path))[0]
                        # ç§»é™¤å¸¸è§çš„å‰ç¼€å’Œåç¼€
                        name = name.replace("Adobe ", "").replace(" 2020", "").replace(" 2021", "").replace(" 2022", "").replace(" 2023", "").replace(" 2024", "")
                    else:
                        # å…¶ä»–è½¯ä»¶ä½¿ç”¨åŸå§‹å¿«æ·æ–¹å¼è·¯å¾„
                        program_path = path
                        name = os.path.splitext(os.path.basename(path))[0]
                    
                    # ç¡®ä¿åç§°å”¯ä¸€
                    base_name = name
                    counter = 1
                    while name in self.paths_data:
                        name = f"{base_name}_{counter}"
                        counter += 1
                    
                    # åˆ›å»ºç¨‹åºä¿¡æ¯
                    program_info = {
                        'path': program_path,
                        'working_dir': os.path.dirname(program_path)
                    }
                    
                    print(f"æ£€æµ‹åˆ°å¿«æ·æ–¹å¼: ğŸ’» {name} -> {program_path}")
                    
                    # æ·»åŠ åˆ°è·¯å¾„æ•°æ®
                    self.paths_data[name] = f"program:{json.dumps(program_info, ensure_ascii=False)}"
                    self._save_paths()
                    self._create_path_buttons()
                    self._show_message("ç¨‹åºå·²æ·»åŠ !")
                    return
                    
                except Exception as e:
                    print(f"å¤„ç†å¿«æ·æ–¹å¼æ—¶å‡ºé”™: {e}")
                    
            # Windows ç³»ç»Ÿä¸‹çš„è·¯å¾„å¤„ç†
            if os.name == 'nt':
                # ç»Ÿä¸€è·¯å¾„åˆ†éš”ç¬¦å¹¶è·å–ç»å¯¹è·¯å¾„
                path = os.path.abspath(path.replace('\\', '/'))
            
            print(f"åŸå§‹è·¯å¾„: {path}")
            
            try:
                # å°è¯•ç›´æ¥ä½¿ç”¨è·¯å¾„
                if os.path.exists(path):
                    print(f"è·¯å¾„ç›´æ¥å­˜åœ¨")
                else:
                    # å¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼Œå°è¯•ä¸åŒçš„ç¼–ç æ–¹å¼
                    try:
                        encoded_path = path.encode('utf-8').decode('utf-8')
                        if os.path.exists(encoded_path):
                            path = encoded_path
                            print(f"ä½¿ç”¨UTF-8ç¼–ç è·¯å¾„")
                    except:
                        try:
                            encoded_path = path.encode('gbk').decode('gbk')
                            if os.path.exists(encoded_path):
                                path = encoded_path
                                print(f"ä½¿ç”¨GBKç¼–ç è·¯å¾„")
                        except:
                            pass
            except Exception as e:
                print(f"è·¯å¾„ç¼–ç å¤„ç†é”™è¯¯: {e}")
            
            print(f"æœ€ç»ˆè·¯å¾„: {path}")
            print(f"è·¯å¾„æ˜¯å¦å­˜åœ¨: {os.path.exists(path)}")
            print(f"æ˜¯å¦æ˜¯æ–‡ä»¶å¤¹: {os.path.isdir(path)}")
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶å¤¹
            if os.path.isdir(path):
                print(f"æ£€æµ‹åˆ°æ–‡ä»¶å¤¹: {path}")
                try:
                    name = os.path.basename(path)
                    base_name = name
                    counter = 1
                    while name in self.paths_data:
                        name = f"{base_name}_{counter}"
                        counter += 1
                    
                    # å­˜å‚¨å®Œæ•´çš„ç»å¯¹è·¯å¾„
                    full_path = os.path.abspath(path)
                    self.paths_data[name] = full_path.replace('\\', '/')
                    print(f"å­˜å‚¨çš„æ–‡ä»¶å¤¹è·¯å¾„: {self.paths_data[name]}")
                    
                    self._save_paths()
                    self._create_path_buttons()
                    self._show_message("æ–‡ä»¶å¤¹å·²æ·»åŠ !")
                    return
                except Exception as e:
                    print(f"å¤„ç†æ–‡ä»¶å¤¹æ—¶å‡ºé”™: {e}")
                    self._show_message("æ·»åŠ æ–‡ä»¶å¤¹å¤±è´¥!")
                    return

            # æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶
            if os.path.isfile(path):
                file_ext = os.path.splitext(path)[1].lower()
                print(f"æ£€æµ‹åˆ°æ–‡ä»¶ï¼Œæ‰©å±•å: {file_ext}")
                
                # ç¡®å®šæ–‡ä»¶ç±»å‹
                file_type = None
                for type_name, extensions in self.SUPPORTED_FORMATS.items():
                    if file_ext in extensions:
                        file_type = type_name
                        break
                
                if file_type:
                    try:
                        name = os.path.basename(path)
                        base_name = name
                        counter = 1
                        while name in self.paths_data:
                            name = f"{base_name}_{counter}"
                            counter += 1
                        
                        # ä½¿ç”¨å¯¹åº”çš„å›¾æ ‡
                        icon = self.FILE_TYPE_ICONS.get(file_type, "ğŸ“„")
                        
                        # å¯¹å·¥ç¨‹æ–‡ä»¶è¿›è¡Œç‰¹æ®Šå¤„ç†
                        if file_type == "å·¥ç¨‹æ–‡ä»¶":
                            if file_ext == '.aep' or file_ext == '.aepx':
                                display_name = f"AE: {name}"
                            elif file_ext == '.uproject':
                                display_name = f"UE: {name}"
                            else:
                                display_name = name
                        else:
                            display_name = name
                        
                        # å­˜å‚¨æ–‡ä»¶ä¿¡æ¯
                        file_info = {
                            'path': path,
                            'type': file_type
                        }
                        
                        self.paths_data[display_name] = f"file:{json.dumps(file_info, ensure_ascii=False)}"
                        self._save_paths()
                        self._create_path_buttons()
                        self._show_message(f"{file_type}å·²æ·»åŠ !")
                        return
                    except Exception as e:
                        print(f"å¤„ç†{file_type}æ–‡ä»¶æ—¶å‡ºé”™: {e}")
                        self._show_message(f"æ·»åŠ {file_type}å¤±è´¥!")
                        return

            # å¦‚æœéƒ½ä¸åŒ¹é…ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            print(f"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: {path}")
            self._show_message("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹!")
            
            # åœ¨æˆåŠŸæ·»åŠ åï¼Œç¡®ä¿æ›´æ–°ç•Œé¢
            is_first_button = len(self.paths_data) <= 2  # ä¿®æ”¹è¿™é‡Œï¼Œå¤„ç†å‰ä¸¤ä¸ªæŒ‰é’®
            
            if is_first_button:
                # å¼ºåˆ¶å®Œæ•´çš„å¸ƒå±€æ›´æ–°
                self.root.update_idletasks()
                self.buttons_frame.update_idletasks()
                self.main_frame.update_idletasks()
                
                # å¼ºåˆ¶è®¾ç½®çª—å£å°ºå¯¸
                self.root.geometry(f"500x{self.root.winfo_height()}")
                
                # å¼ºåˆ¶æ›´æ–°æ‰€æœ‰æ¡†æ¶
                self.main_frame.update()
                self.buttons_frame.update()
                
                # å»¶è¿Ÿåˆ›å»ºæŒ‰é’®ï¼Œç¡®ä¿çª—å£å°ºå¯¸å·²æ›´æ–°
                def delayed_update():
                    self._create_path_buttons()
                    self.canvas.configure(scrollregion=self.canvas.bbox("all"))
                    self.canvas.yview_moveto(0)
                    # å†æ¬¡å¼ºåˆ¶æ›´æ–°å¸ƒå±€
                    self.root.update_idletasks()
                
                # ä½¿ç”¨æ›´é•¿çš„å»¶è¿Ÿç¡®ä¿å¸ƒå±€å·²å®Œå…¨å‡†å¤‡å¥½
                self.root.after(100, delayed_update)
            else:
                self._create_path_buttons()
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
                self.canvas.yview_moveto(0)
                
        except Exception as e:
            print(f"æ‹–æ”¾å¤„ç†æ—¶å‡ºé”™: {e}")
            self._show_message(f"æ·»åŠ å¤±è´¥: {str(e)}")
    def _get_shortcut_info(self, shortcut_path):
        """è·å–å¿«æ·æ–¹å¼ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        if shortcut_path in self._path_info_cache:
            return self._path_info_cache[shortcut_path]
            
        info = self._fetch_shortcut_info(shortcut_path)
        self._path_info_cache[shortcut_path] = info
        return info
    def _fetch_shortcut_info(self, shortcut_path):
        """è·å–å¿«æ·æ–¹å¼ä¿¡æ¯"""
        try:
            print(f"Getting info for: {shortcut_path}")
            
            # è·å–ä¸å¸¦æ‰©å±•åçš„æ–‡ä»¶åä½œä¸ºæ˜¾ç¤ºåç§°
            name = os.path.splitext(os.path.basename(shortcut_path))[0]
            
            # è½¯ä»¶ç‰¹å¾è¯†åˆ«é…ç½®
            software_patterns = {
                "adobe": {
                    "name": "Adobe",
                    "patterns": ["photoshop", "illustrator", "premiere", "after effects"],
                    "apps": {
                        "photoshop": ("Photoshop", "ğŸ¨"),
                        "illustrator": ("Illustrator", "ğŸ¨"),
                        "premiere": ("Premiere Pro", "ğŸ¬"),
                        "after effects": ("After Effects", "ğŸ¬"),
                        "lightroom": ("Lightroom", "ğŸ¨"),
                        "indesign": ("InDesign", "ğŸ¨"),
                        "acrobat": ("Acrobat", "ğŸ“„")
                    }
                },
                "office": {
                    "name": "Office",
                    "patterns": ["word", "excel", "powerpoint", "outlook"],
                    "apps": {
                        "word": ("Word", "ğŸ“„"),
                        "excel": ("Excel", "ğŸ“Š"),
                        "powerpoint": ("PowerPoint", "ğŸ“Š"),
                        "outlook": ("Outlook", "ğŸ“§")
                    }
                },
                "browser": {
                    "name": "æµè§ˆå™¨",
                    "patterns": ["chrome", "firefox", "edge", "opera"],
                    "apps": {
                        "chrome": "Chrome",
                        "firefox": "Firefox",
                        "edge": "Edge",
                        "opera": "Opera"
                    },
                    "icon": "ğŸŒ"
                }
            }
            
            # å¤„ç†å¿«æ·æ–¹å¼ä¿¡æ¯
            shell = Dispatch("WScript.Shell")
            shortcut = shell.CreateShortCut(shortcut_path)
            target_path = shortcut.Targetpath
            arguments = shortcut.Arguments
            working_dir = shortcut.WorkingDirectory or os.path.dirname(shortcut_path)
            
            # æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½•è½¯ä»¶æ¨¡å¼
            name_lower = name.lower()
            for software, config in software_patterns.items():
                # å¯¹äº Adobe å’Œ Office åº”ç”¨ç¨‹åºçš„ç‰¹æ®Šå¤„ç†
                if software in ["adobe", "office"]:
                    for app_key, (app_name, icon) in config["apps"].items():
                        if app_key in name_lower:
                            display_name = f"{icon} {app_name}"
                            return display_name, target_path, arguments, working_dir
            
            # å¦‚æœæ²¡æœ‰åŒ¹é…çš„ç‰¹æ®Šè½¯ä»¶ï¼Œè¿”å›åŸå§‹åç§°å’Œè·¯å¾„ä¿¡æ¯
            return name, target_path, arguments, working_dir
            
        except Exception as e:
            print(f"Error in get_shortcut_info: {e}")
            return name, shortcut_path, "", os.path.dirname(shortcut_path)
    def _clean_name(self, original_name):
        """æ¸…ç†åç§°"""
        try:
            # å¸¸è§çš„éœ€è¦æ¸…ç†çš„åç¼€å’Œå‰ç¼€
            clean_terms = [
                "- shortcut", "shortcut", ".exe", ".lnk",
                "launcher", "start", "run",
                # æ¸¸æˆå¹³å°
                "steam", "epic", "ubisoft", "ea", "origin", 
                "battle.net", "battlenet", "riot", "rockstar",
                # ç‰ˆæœ¬æ ‡è¯†
                "x64", "x86", "(x64)", "(x86)", "64-bit", "32-bit",
                # å…¶ä»–å¸¸è§åç¼€
                "setup", "install", "uninstall",
                # ç‰¹æ®Šå­—ç¬¦
                "â„¢", "Â®", "Â©"
            ]
            
            display_name = original_name
            
            # ç§»é™¤æ‹¬å·åŠå…¶å†…å®¹
            display_name = re.sub(r'\([^)]*\)', '', display_name)
            display_name = re.sub(r'\[[^\]]*\]', '', display_name)
            
            # æ¸…ç†æŒ‡å®šçš„æœ¯è¯­
            for term in clean_terms:
                if display_name.lower().endswith(term.lower()):
                    display_name = display_name[:-len(term)].strip()
                if display_name.lower().startswith(term.lower()):
                    display_name = display_name[len(term):].strip()
            
            # æ¸…ç†å¤šä½™çš„ç©ºæ ¼ã€ç ´æŠ˜å·å’Œä¸‹åˆ’çº¿
            display_name = display_name.strip(" -_")
            # å°†å¤šä¸ªç©ºæ ¼æ›¿æ¢ä¸ºå•ä¸ªç©ºæ ¼
            display_name = ' '.join(display_name.split())
            
            # ç‰¹æ®Šå¤„ç† UE/è™šå¹»å¼•æ“
            if "unreal" in display_name.lower() or "ue" in display_name.lower():
                version_match = re.search(r'(\d+\.?\d*)', display_name)
                if version_match:
                    display_name = f"è™šå¹»å¼•æ“ {version_match.group(1)}"
                else:
                    display_name = "è™šå¹»å¼•æ“"
            
            # å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œè¿”å›åŸå§‹åç§°
            return display_name if display_name else original_name
            
        except Exception as e:
            print(f"Error in _clean_name: {e}")  # è°ƒè¯•ä¿¡æ¯
            return original_name
    def _open_program(self, program_path, arguments=None, working_dir=None):
        """æ‰“å¼€ç¨‹åº"""
        try:
            # æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
            if not os.path.exists(program_path):
                self._show_message("ç¨‹åºè·¯å¾„ä¸å­˜åœ¨!")
                return

            # å¦‚æœæ˜¯å¿«æ·æ–¹å¼(.lnkæ–‡ä»¶)
            if program_path.lower().endswith('.lnk'):
                try:
                    shell = Dispatch("WScript.Shell")
                    shortcut = shell.CreateShortCut(program_path)
                    program_path = shortcut.Targetpath
                    if not arguments:
                        arguments = shortcut.Arguments
                    if not working_dir:
                        working_dir = shortcut.WorkingDirectory
                except Exception as e:
                    print(f"è§£æå¿«æ·æ–¹å¼å¤±è´¥: {e}")
                    self._show_message("æ— æ³•è§£æå¿«æ·æ–¹å¼!")
                    return

            # å‡†å¤‡å¯åŠ¨å‚æ•°
            startup_info = subprocess.STARTUPINFO()
            startup_info.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            
            # æ„å»ºå‘½ä»¤
            cmd = [program_path]
            if arguments:
                cmd.extend(arguments.split())

            # å¯åŠ¨ç¨‹åº
            subprocess.Popen(
                cmd,
                cwd=working_dir if working_dir else os.path.dirname(program_path),
                startupinfo=startup_info,
                shell=True  # æ·»åŠ shell=Trueä»¥æ›´å¥½åœ°å¤„ç†è·¯å¾„ä¸­çš„ç©ºæ ¼
            )

        except Exception as e:
            print(f"å¯åŠ¨ç¨‹åºå¤±è´¥: {e}")
            self._show_message("æ— æ³•å¯åŠ¨ç¨‹åº!")
    def _on_button_click(self, path):
        """å¤„ç†æŒ‰é’®ç‚¹å‡»äº‹ä»¶"""
        try:
            # å¦‚æœå¯ç”¨äº†å¤åˆ¶è·¯å¾„åŠŸèƒ½
            if self.copy_path_enabled.get():
                actual_path = ""
                
                # è§£æä¸åŒç±»å‹çš„è·¯å¾„
                if isinstance(path, str):
                    if path.startswith('program:'):
                        data = json.loads(path.split(':', 1)[1])
                        actual_path = data['path']
                    elif path.startswith('file:'):
                        data = json.loads(path.split(':', 1)[1])
                        actual_path = data['path']
                    elif path.startswith('web:'):
                        data = json.loads(path.split(':', 1)[1])
                        actual_path = data['url']
                    elif path.startswith('folder:'):
                        data = json.loads(path.split(':', 1)[1])
                        actual_path = data['path']
                    else:
                        actual_path = path
                
                # å¤åˆ¶è·¯å¾„åˆ°å‰ªè´´æ¿
                self.root.clipboard_clear()
                self.root.clipboard_append(actual_path)
                self._show_message("è·¯å¾„å·²å¤åˆ¶!")
                return
            
            # å¤„ç†ä¸åŒç±»å‹çš„è·¯å¾„æ‰“å¼€
            if isinstance(path, str):
                if path.startswith('program:'):
                    data = json.loads(path.split(':', 1)[1])
                    self._open_program(data['path'], data.get('arguments'), data.get('working_dir'))
                elif path.startswith('file:'):
                    data = json.loads(path.split(':', 1)[1])
                    self._open_file(data['path'])
                elif path.startswith('web:'):
                    data = json.loads(path.split(':', 1)[1])
                    webbrowser.open(data['url'])
                elif path.startswith('folder:'):
                    data = json.loads(path.split(':', 1)[1])
                    self._open_path(data['path'])
                else:
                    # ç›´æ¥çš„æ–‡ä»¶å¤¹è·¯å¾„
                    self._open_path(path)
                
        except Exception as e:
            print(f"æŒ‰é’®ç‚¹å‡»å¤„ç†é”™è¯¯: {e}")
            self._show_message("æ‰“å¼€å¤±è´¥!")
    def _is_game_directory(self, path):
        """æ£€æŸ¥æ˜¯å¦æ˜¯æ¸¸æˆç›®å½•"""
        if not os.path.isdir(path):
            return False
            
        # æ¸¸æˆç›®å½•ç‰¹å¾
        game_indicators = [
            '.exe',  # å¯æ‰§è¡Œæ–‡ä»¶
            'steam_api.dll',  # Steamæ¸¸æˆç‰¹å¾
            'UE4Game',  # è™šå¹»å¼•æ“æ¸¸æˆç‰¹å¾
            'UnityPlayer.dll',  # Unityæ¸¸æˆç‰¹å¾
            'GameData',  # é€šç”¨æ¸¸æˆæ•°æ®ç›®å½•
            'Binaries',  # æ¸¸æˆäºŒè¿›åˆ¶æ–‡ä»¶ç›®å½•
            'SaveGames'  # æ¸¸æˆå­˜æ¡£ç›®å½•
        ]
        
        # æ£€æŸ¥ç›®å½•å†…å®¹
        dir_contents = os.listdir(path)
        exe_files = [f for f in dir_contents if f.lower().endswith('.exe')]
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ¸¸æˆç‰¹å¾
        has_indicators = any(indicator.lower() in str(dir_contents).lower() 
                           for indicator in game_indicators)
        
        return bool(exe_files) and has_indicators

    def _check_special_software(self, path):
        """æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šè½¯ä»¶"""
        path_lower = path.lower()
        
        # æ£€æŸ¥æ˜¯å¦åŒ¹é…ç‰¹æ®Šè½¯ä»¶è·¯å¾„
        for software, config in self.SPECIAL_SOFTWARE_PATHS.items():
            for possible_path in config["possible_paths"]:
                if os.path.exists(possible_path) and (
                    path_lower in possible_path.lower() or 
                    possible_path.lower() in path_lower
                ):
                    return {
                        "name": config["name"],
                        "path": possible_path,
                        "icon": config["icon"]
                    }
        return None

    def _add_special_software_shortcut(self, software):
        """æ·»åŠ ç‰¹æ®Šè½¯ä»¶å¿«æ·æ–¹å¼"""
        display_name = f"{software['icon']} {software['name']}"
        
        # å¦‚æœåç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
        base_name = display_name
        counter = 1
        while display_name in self.paths_data:
            display_name = f"{base_name}_{counter}"
            counter += 1
        
        # å­˜å‚¨ç¨‹åºä¿¡æ¯
        program_info = {
            'path': software['path'],
            'arguments': '',
            'working_dir': os.path.dirname(software['path'])
        }
        
        self.paths_data[display_name] = f"program:{json.dumps(program_info)}"
        self._save_paths()
        self._create_path_buttons()
        self._show_message(f"{software['name']}å·²æ·»åŠ !")

    def _add_game_shortcut(self, path):
        """æ·»åŠ æ¸¸æˆå¿«æ·æ–¹å¼"""
        # æŸ¥æ‰¾ä¸»ç¨‹åº
        exe_files = []
        for root, dirs, files in os.walk(path):
            for file in files:
                if file.lower().endswith('.exe'):
                    exe_files.append(os.path.join(root, file))
        
        if not exe_files:
            self._show_message("æœªæ‰¾åˆ°æ¸¸æˆä¸»ç¨‹åº!")
            return
            
        # å°è¯•æ‰¾åˆ°ä¸»ç¨‹åºï¼ˆé€šå¸¸æ˜¯è¾ƒå¤§çš„exeæ–‡ä»¶ï¼‰
        main_exe = max(exe_files, key=lambda f: os.path.getsize(f))
        
        # è·å–æ¸¸æˆåç§°
        game_name = os.path.basename(path)
        display_name = f"ğŸ® {game_name}"
        
        # å¦‚æœåç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
        base_name = display_name
        counter = 1
        while display_name in self.paths_data:
            display_name = f"{base_name}_{counter}"
            counter += 1
        
        # å­˜å‚¨ç¨‹åºä¿¡æ¯
        program_info = {
            'path': main_exe,
            'arguments': '',
            'working_dir': path
        }
        
        self.paths_data[display_name] = f"program:{json.dumps(program_info)}"
        self._save_paths()
        self._create_path_buttons()
        self._show_message("æ¸¸æˆå·²æ·»åŠ !")
    def _show_image_preview(self, image_path):
        """æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆçª—å£"""
        try:
            # å¦‚æœå·²ç»æœ‰é¢„è§ˆçª—å£ï¼Œå…ˆå…³é—­å®ƒ
            if self.preview_window and self.preview_window.winfo_exists():
                self.preview_window.destroy()
            
            # åˆ›å»ºé¢„è§ˆçª—å£
            self.preview_window = tk.Toplevel(self.root)
            self.preview_window.title("å›¾ç‰‡é¢„è§ˆ")
            self.preview_window.configure(bg="#2b2b2b")
            self.preview_window.iconbitmap(self.icon_path)  # è®¾ç½®é¢„è§ˆçª—å£å›¾æ ‡
            
            # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
            preview_width = self.IMAGE_PREVIEW_SIZE[0] + 40
            preview_height = self.IMAGE_PREVIEW_SIZE[1] + 60
            x = self.root.winfo_x() + (self.root.winfo_width() - preview_width) // 2
            y = self.root.winfo_y() + (self.root.winfo_height() - preview_height) // 2
            self.preview_window.geometry(f"{preview_width}x{preview_height}+{x}+{y}")
            
            # åŠ è½½å¹¶è°ƒæ•´å›¾ç‰‡å¤§å°
            image = Image.open(image_path)
            image.thumbnail(self.IMAGE_PREVIEW_SIZE)
            photo = ImageTk.PhotoImage(image)
            
            # åˆ›å»ºå›¾ç‰‡æ ‡ç­¾
            image_label = tk.Label(
                self.preview_window,
                image=photo,
                bg="#2b2b2b",
                bd=2,
                relief="solid"
            )
            image_label.image = photo  # ä¿æŒå¼•ç”¨
            image_label.pack(pady=10)
            
            # æ·»åŠ æ–‡ä»¶åæ ‡ç­¾
            name_label = tk.Label(
                self.preview_window,
                text=os.path.basename(image_path),
                bg="#2b2b2b",
                fg="white",
                font=self.FONT_NORMAL
            )
            name_label.pack(pady=5)
            
            # æ·»åŠ å…³é—­æŒ‰é’®
            close_btn = tk.Button(
                self.preview_window,
                text="å…³é—­",
                command=self.preview_window.destroy,
                bg="#4c5052",
                fg="white",
                activebackground="#5c6062",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL
            )
            close_btn.pack(pady=5)
            
        except Exception as e:
            print(f"Error showing image preview: {e}")
            self._show_message("æ— æ³•é¢„è§ˆå›¾ç‰‡!")
    def _create_hot_corner_detector(self):
        """åˆ›å»ºçƒ­åŒºæ£€æµ‹å™¨çª—å£"""
        self.detector = tk.Toplevel(self.root)
        self.detector.withdraw()  # åˆå§‹æ—¶éšè—
        self.detector.overrideredirect(True)
        self.detector.attributes('-alpha', 0.01)  # å‡ ä¹å®Œå…¨é€æ˜
        self.detector.attributes('-topmost', True)  # çƒ­åŒºå§‹ç»ˆç½®é¡¶
        
        # è®¾ç½®çƒ­åŒºä½ç½®å’Œå¤§å°
        self.detector.geometry(f"{self.hot_corner_size}x{self.hot_corner_size}+0+0")
        
        # æ”¹ä¸ºç»‘å®šé¼ æ ‡ç‚¹å‡»äº‹ä»¶
        self.detector.bind("<Button-1>", self._on_hot_corner_activated)
        
        # ç¡®ä¿çƒ­åŒºå§‹ç»ˆå¯ç”¨
        self._ensure_hot_corner_visible()

    def _ensure_hot_corner_visible(self):
        """ç¡®ä¿çƒ­åŒºå§‹ç»ˆå¯è§å’Œç½®é¡¶"""
        if hasattr(self, 'detector'):
            self.detector.lift()  # å°†çƒ­åŒºçª—å£æå‡åˆ°æœ€é¡¶å±‚
            self.detector.attributes('-topmost', True)  # ç¡®ä¿çƒ­åŒºå§‹ç»ˆç½®é¡¶
        # æ¯500æ¯«ç§’æ£€æŸ¥ä¸€æ¬¡
        self.root.after(500, self._ensure_hot_corner_visible)

    def _on_minimize(self, event):
        """çª—å£æœ€å°åŒ–æ—¶æ¿€æ´»çƒ­åŒº"""
        self.hot_corner_active = True
        self.detector.deiconify()  # æ˜¾ç¤ºçƒ­åŒºæ£€æµ‹å™¨
        self.detector.lift()  # ç¡®ä¿çƒ­åŒºåœ¨æœ€é¡¶å±‚
        self.detector.attributes('-topmost', True)  # ç¡®ä¿çƒ­åŒºç½®é¡¶

    def _on_restore(self, event):
        """çª—å£æ¢å¤æ—¶ç¦ç”¨çƒ­åŒº"""
        self.hot_corner_active = False
        self.detector.withdraw()  # éšè—çƒ­åŒºæ£€æµ‹å™¨
        
    def _on_hot_corner_activated(self, event):
        """å½“ç‚¹å‡»çƒ­åŒºæ—¶"""
        if self.hot_corner_active:
            # æ¢å¤çª—å£
            self.root.deiconify()
            self.root.lift()  # å°†çª—å£ç½®äºé¡¶å±‚
            
            # å¦‚æœå¼€å¯äº†ç½®é¡¶ï¼Œç¡®ä¿çª—å£ä¿æŒç½®é¡¶
            if self.is_topmost.get():
                self.root.attributes('-topmost', True)
            
            self.root.focus_force()  # å¼ºåˆ¶è·å–ç„¦ç‚¹
            
            # ç§»åŠ¨åˆ°åŸæ¥çš„ä½ç½®
            x = 20  # è·ç¦»å·¦è¾¹ç¼˜20åƒç´ 
            y = 20  # è·ç¦»ä¸Šè¾¹ç¼˜20åƒç´ 
            self.root.geometry(f"+{x}+{y}")
            
            # ç¦ç”¨çƒ­åŒº
            self.hot_corner_active = False
            self.detector.withdraw()
    def _create_tooltip(self, widget, text):
        """åˆ›å»ºå·¥å…·æç¤º"""
        def enter(event):
            # ä½¿ç”¨å†…éƒ¨æŒ‰é’®ç»„ä»¶æ¥å­˜å‚¨tooltip
            button = widget.button if hasattr(widget, 'button') else widget
            
            # ç¡®ä¿ä¹‹å‰çš„tooltipè¢«æ¸…ç†
            if hasattr(button, 'tooltip') and button.tooltip.winfo_exists():
                button.tooltip.destroy()
            
            try:
                tooltip = tk.Toplevel()
                button.tooltip = tooltip  # å°†tooltipç»‘å®šåˆ°å†…éƒ¨æŒ‰é’®
                tooltip.withdraw()
                tooltip.wm_overrideredirect(True)
                
                # åˆ›å»ºåœ†è§’æ¡†æ¶
                frame = tk.Frame(
                    tooltip,
                    bg="#1e1e1e",
                    bd=1,
                    relief="solid",
                    highlightbackground="#4c5052",
                    highlightthickness=1
                )
                frame.pack(padx=2, pady=2)
                
                # æ·»åŠ å›¾æ ‡
                icon_label = tk.Label(
                    frame,
                    text="â„¹ï¸",
                    bg="#1e1e1e",
                    fg="white",
                    font=self.FONT_NORMAL
                )
                icon_label.pack(side="left", padx=(5,2))
                
                # æ–‡æœ¬æ ‡ç­¾
                label = tk.Label(
                    frame,
                    text=text,
                    justify=tk.LEFT,
                    bg="#1e1e1e",
                    fg="white",
                    font=self.FONT_NORMAL
                )
                label.pack(side="left", padx=(2,5), pady=2)
                
                # æ·¡å…¥æ•ˆæœ
                tooltip.update_idletasks()
                tooltip.deiconify()
                tooltip.attributes('-alpha', 0.0)
                
                x = widget.winfo_rootx()
                y = widget.winfo_rooty() + widget.winfo_height() + 5
                tooltip.geometry(f"+{x}+{y}")
                
                for i in range(10):
                    if not tooltip.winfo_exists():
                        break
                    tooltip.attributes('-alpha', i/10)
                    tooltip.update()
                    time.sleep(0.01)
            except Exception as e:
                print(f"Tooltip creation error: {e}")
        
        def leave(event):
            try:
                button = widget.button if hasattr(widget, 'button') else widget
                if hasattr(button, "tooltip") and button.tooltip.winfo_exists():
                    button.tooltip.destroy()
            except Exception as e:
                print(f"Tooltip destruction error: {e}")
        
        # ç»‘å®šäº‹ä»¶åˆ°å†…éƒ¨æŒ‰é’®
        if hasattr(widget, 'button'):
            widget.button.bind('<Enter>', enter)
            widget.button.bind('<Leave>', leave)
        else:
            widget.bind('<Enter>', enter)
            widget.bind('<Leave>', leave)
    def _setup_hotkeys(self):
        """è®¾ç½®å¿«æ·é”®"""
        self.root.bind('<Control-q>', lambda e: self.root.quit())
        self.root.bind('<Escape>', lambda e: self.root.iconify())
    def _check_backup_status(self):
        """æ£€æŸ¥å¤‡ä»½çŠ¶æ€"""
        last_backup = self._get_last_backup_time()
        if (datetime.now() - last_backup).days >= 7:
            self._show_backup_reminder()
    def _on_window_configure(self, event):
        """å¤„ç†çª—å£é…ç½®å˜åŒ–äº‹ä»¶"""
        if event.widget == self.root:
            # è·å–å½“å‰çª—å£å¤§å°
            current_size = (self.root.winfo_width(), self.root.winfo_height())
            
            # å¦‚æœå¤§å°å‘ç”Ÿå˜åŒ–
            if not hasattr(self, '_last_window_size') or current_size != self._last_window_size:
                # å–æ¶ˆä¹‹å‰çš„è®¡æ—¶å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if hasattr(self, '_resize_timer'):
                    self.root.after_cancel(self._resize_timer)
                
                # è®¾ç½®æ–°çš„è®¡æ—¶å™¨
                self._resize_timer = self.root.after(50, self._create_path_buttons)  # å‡å°‘å»¶è¿Ÿæ—¶é—´
                self._last_window_size = current_size

    def _update_buttons_layout(self):
        """æ›´æ–°æŒ‰é’®å¸ƒå±€"""
        try:
            # è·å–å½“å‰å¸ƒå±€çŠ¶æ€
            current_width = self.root.winfo_width()
            min_button_width = 220
            current_buttons_per_row = min(2, max(1, (current_width - 80) // min_button_width))
            
            # è®¡ç®—å½“å‰çš„æŒ‰é’®å¸ƒå±€
            if not hasattr(self, '_current_buttons_per_row'):
                self._current_buttons_per_row = current_buttons_per_row
            
            # åªæœ‰å½“å¸ƒå±€çœŸæ­£éœ€è¦æ”¹å˜æ—¶æ‰é‡å»ºæŒ‰é’®
            if current_buttons_per_row != self._current_buttons_per_row:
                self._create_path_buttons()
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
                self._current_buttons_per_row = current_buttons_per_row
                
        except Exception as e:
            print(f"Update buttons layout error: {e}")
    def _toggle_topmost(self):
        """åˆ‡æ¢çª—å£ç½®é¡¶çŠ¶æ€"""
        is_top = self.is_topmost.get()
        self.root.attributes('-topmost', is_top)
        self._show_message("ç½®é¡¶å·²" + ("å¼€å¯" if is_top else "å…³é—­"))
    def _toggle_note(self):
        """åˆ‡æ¢ä¸´æ—¶ç¬”è®°æ˜¾ç¤ºçŠ¶æ€"""
        is_enabled = self.note_enabled.get()
        
        if is_enabled:
            # è®¾ç½®ç¬”è®°åŒºåŸŸçš„é«˜åº¦å¹¶æ˜¾ç¤º
            self.note_container.configure(height=90)
            self.note_container.pack(side="top", fill="x", pady=(5, 0))
            
            # å¦‚æœæ˜¯é»˜è®¤æ–‡æœ¬ï¼Œæ¸…ç©ºå¹¶è®¾ç½®ä¸ºç¼–è¾‘çŠ¶æ€
            if self.temp_input.get("1.0", "end-1c").strip() == "ä¸´æ—¶ç¬”è®°...":
                self.temp_input.delete("1.0", tk.END)
                self.temp_input.config(fg='white')
            
            self.temp_input.focus_set()
        else:
            # ä¿å­˜æˆ–åˆ é™¤ç¬”è®°å†…å®¹
            current_text = self.temp_input.get("1.0", "end-1c").strip()
            if current_text and current_text != "ä¸´æ—¶ç¬”è®°...":
                self._save_notes()
            else:
                # å¦‚æœå†…å®¹ä¸ºç©ºï¼Œåˆ é™¤ç¬”è®°æ–‡ä»¶
                if os.path.exists(self.notes_file):
                    os.remove(self.notes_file)
            
            # éšè—ç¬”è®°åŒºåŸŸ
            self.note_container.pack_forget()
    def run(self):
        """è¿è¡Œç¨‹åº"""
        self.root.mainloop()

    def _is_valid_url(self, url):
        """æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„URL"""
        try:
            # æ¸…ç†URL
            url = url.strip().lower()
            
            # å¦‚æœURLä»¥www.å¼€å¤´ï¼Œæ·»åŠ https://
            if url.startswith('www.'):
                url = 'https://' + url
                
            # åŸºæœ¬URLæ ¼å¼éªŒè¯
            if not any(url.startswith(prefix) for prefix in ('http://', 'https://')):
                return False
                
            # ä½¿ç”¨urlparseè¿›è¡Œæ›´ä¸¥æ ¼çš„éªŒè¯
            parsed = urlparse(url)
            
            # æ£€æŸ¥å¿…è¦çš„URLç»„ä»¶
            if not all([parsed.scheme, parsed.netloc]):
                return False
                
            # æ£€æŸ¥åŸŸåæ ¼å¼
            if not parsed.netloc or '.' not in parsed.netloc:
                return False
                
            # æ£€æŸ¥åŸŸåé•¿åº¦
            if len(parsed.netloc) < 4:  # æœ€çŸ­çš„æœ‰æ•ˆåŸŸåè‡³å°‘éœ€è¦4ä¸ªå­—ç¬¦ (å¦‚ a.io)
                return False
                
            return True
        
        except Exception as e:
            print(f"URLéªŒè¯é”™è¯¯: {e}")
            return False

    def _open_url(self, url):
        """ä½¿ç”¨é»˜è®¤æµè§ˆå™¨æ‰“å¼€URL"""
        try:
            # æ¸…ç†URL
            url = url.strip()
            # å¦‚æœURLä»¥www.å¼€å¤´ï¼Œæ·»åŠ https://
            if url.startswith('www.'):
                url = 'https://' + url
                
            # ä½¿ç”¨webbrowseræ¨¡å—æ‰“å¼€URL
            webbrowser.open(url, new=2)  # new=2è¡¨ç¤ºåœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€
            return True
        except Exception as e:
            print(f"æ‰“å¼€URLé”™è¯¯: {e}")
            self._show_message("æ— æ³•æ‰“å¼€ç½‘é¡µ!")
            return False

    def _add_web_shortcut(self, url):
        """æ·»åŠ ç½‘é¡µå¿«æ·æ–¹å¼"""
        try:
            # æ¸…ç†URL
            url = url.strip()
            if url.startswith('www.'):
                url = 'https://' + url
                
            # ä»URLä¸­æå–åç§°
            parsed_url = urlparse(url)
            name = parsed_url.netloc
            
            # ç§»é™¤www.å‰ç¼€
            if name.startswith('www.'):
                name = name[4:]
                
            # æå–åŸŸåä¸»è¦éƒ¨åˆ†ï¼ˆä¾‹å¦‚ä» google.com ä¸­æå– googleï¼‰
            name = name.split('.')[0]
            
            print(f"å¤„ç†URL: {url}")
            print(f"æå–çš„åç§°: {name}")
            
            # æ¸…ç†åç§°ä¸­çš„ç‰¹æ®Šå­—ç¬¦
            name = ''.join(c for c in name if c.isalnum() or c in '-._')
            
            # ç¡®ä¿åç§°å”¯ä¸€
            base_name = name
            counter = 1
            while name in self.paths_data:
                name = f"{base_name}_{counter}"
                counter += 1
            
            # åˆ›å»ºç½‘é¡µä¿¡æ¯
            web_info = {
                'url': url,
                'type': 'web',
                'colors': self.BUTTON_STYLES["web"]  # ä½¿ç”¨é»˜è®¤çš„ç½‘é¡µæŒ‰é’®æ ·å¼
            }
            
            # æ·»åŠ åˆ°è·¯å¾„æ•°æ®
            self.paths_data[name] = f"web:{json.dumps(web_info, ensure_ascii=False)}"
            
            # ä¿å­˜å¹¶æ›´æ–°ç•Œé¢
            self._save_paths()
            self._create_path_buttons()
            
            # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            self._show_message("ç½‘é¡µå·²æ·»åŠ !", important=True)
            return True
        
        except Exception as e:
            print(f"æ·»åŠ ç½‘é¡µå¿«æ·æ–¹å¼æ—¶å‡ºé”™: {e}")
            self._show_message("æ·»åŠ ç½‘é¡µå¤±è´¥!", important=True)
            return False

    def _handle_paste(self, event):
        """å¤„ç†ç²˜è´´äº‹ä»¶"""
        try:
            # è·å–å½“å‰ç„¦ç‚¹æ‰€åœ¨çš„æ§ä»¶
            focused_widget = self.root.focus_get()
            
            # å¦‚æœç„¦ç‚¹åœ¨ç¬”è®°è¾“å…¥æ¡†ä¸­ä¸”ç¬”è®°åŠŸèƒ½å·²å¯ç”¨ï¼Œä¸å¤„ç†URLæ·»åŠ 
            if focused_widget == self.temp_input and self.note_enabled.get():
                return None  # è®©ç³»ç»Ÿå¤„ç†é»˜è®¤çš„ç²˜è´´è¡Œä¸º
            
            # è·å–å‰ªè´´æ¿å†…å®¹å¹¶æ¸…ç†
            try:
                clipboard_text = self.root.clipboard_get().strip()
                # ç§»é™¤å¯èƒ½çš„å¼•å·
                clipboard_text = clipboard_text.strip('"\'')
                print(f"å¤„ç†å‰ªè´´æ¿å†…å®¹: {clipboard_text}")
            except:
                print("è·å–å‰ªè´´æ¿å†…å®¹å¤±è´¥")
                return None
                
            # å¦‚æœå†…å®¹ä¸ºç©ºï¼Œç›´æ¥è¿”å›
            if not clipboard_text:
                return None
                
            # æ£€æŸ¥æ˜¯å¦æ˜¯URL
            if self._is_valid_url(clipboard_text):
                print(f"æ£€æµ‹åˆ°æœ‰æ•ˆURL: {clipboard_text}")
                if self._add_web_shortcut(clipboard_text):
                    print("URLæ·»åŠ æˆåŠŸ")
                    return 'break'  # é˜»æ­¢äº‹ä»¶ç»§ç»­ä¼ æ’­
                
            return None
                
        except Exception as e:
            print(f"å¤„ç†ç²˜è´´äº‹ä»¶æ—¶å‡ºé”™: {e}")
            return None

    def _load_notes(self):
        """åŠ è½½ä¿å­˜çš„ç¬”è®°"""
        try:
            if os.path.exists(self.notes_file):
                with open(self.notes_file, 'r', encoding='utf-8') as f:
                    saved_text = f.read()
                    if saved_text and saved_text != "ä¸´æ—¶ç¬”è®°...":
                        self.temp_input.delete("1.0", tk.END)
                        self.temp_input.insert("1.0", saved_text)
                        self.temp_input.config(fg='white')
        except Exception as e:
            print(f"åŠ è½½ç¬”è®°å¤±è´¥: {e}")

    def _save_notes(self):
        """ä¿å­˜ç¬”è®°å†…å®¹"""
        try:
            text = self.temp_input.get("1.0", "end-1c").strip()
            if text and text != "ä¸´æ—¶ç¬”è®°...":
                # å¦‚æœæœ‰å†…å®¹ï¼Œä¿å­˜åˆ°æ–‡ä»¶
                with open(self.notes_file, 'w', encoding='utf-8') as f:
                    f.write(text)
            else:
                # å¦‚æœç¬”è®°å†…å®¹ä¸ºç©ºï¼Œåˆ é™¤ç¬”è®°æ–‡ä»¶
                if os.path.exists(self.notes_file):
                    os.remove(self.notes_file)
                
        except Exception as e:
            print(f"ä¿å­˜ç¬”è®°å¤±è´¥: {e}")
            self._show_message("ç¬”è®°ä¿å­˜å¤±è´¥!")

    def _show_rename_dialog(self, old_name):
        """æ˜¾ç¤ºé‡å‘½åå¯¹è¯æ¡†"""
        try:
            # åˆ›å»ºå¯¹è¯æ¡†çª—å£
            dialog = tk.Toplevel(self.root)
            dialog.title("é‡å‘½å")
            dialog.configure(bg="#2b2b2b")
            dialog.transient(self.root)
            
            # åªåœ¨å›¾æ ‡å­˜åœ¨æ—¶è®¾ç½®å›¾æ ‡
            if self.icon_path and os.path.exists(self.icon_path):
                try:
                    dialog.iconbitmap(self.icon_path)
                except:
                    pass
            
            # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
            window_width = 300
            window_height = 120
            x = self.root.winfo_x() + (self.root.winfo_width() - window_width) // 2
            y = self.root.winfo_y() + (self.root.winfo_height() - window_height) // 2
            dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # åˆ›å»ºè¾“å…¥æ¡†æ¶
            frame = tk.Frame(dialog, bg="#2b2b2b", padx=20, pady=10)
            frame.pack(fill="both", expand=True)
            
            # æ·»åŠ æ ‡ç­¾
            label = tk.Label(
                frame,
                text="æ–°åç§°:",
                bg="#2b2b2b",
                fg="white",
                font=self.FONT_NORMAL
            )
            label.pack(anchor="w", pady=(0, 5))
            
            # æ·»åŠ è¾“å…¥æ¡†
            entry = tk.Entry(
                frame,
                bg="#1e1e1e",
                fg="white",
                insertbackground="white",
                relief="flat",
                font=self.FONT_NORMAL
            )
            entry.pack(fill="x", pady=(0, 10))
            entry.insert(0, old_name)
            entry.select_range(0, tk.END)
            entry.focus_set()
            
            # åˆ›å»ºæŒ‰é’®æ¡†æ¶
            btn_frame = tk.Frame(frame, bg="#2b2b2b")
            btn_frame.pack(fill="x")
            
            # ç¡®è®¤æŒ‰é’®
            def confirm_rename():
                new_name = entry.get().strip()
                if new_name and new_name != old_name:
                    self._rename_shortcut(old_name, new_name)
                dialog.destroy()
            
            confirm_btn = tk.Button(
                btn_frame,
                text="ç¡®è®¤",
                command=confirm_rename,
                bg="#4c5052",
                fg="white",
                activebackground="#5c6062",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL
            )
            confirm_btn.pack(side="left", padx=5)
            
            # å–æ¶ˆæŒ‰é’®
            cancel_btn = tk.Button(
                btn_frame,
                text="å–æ¶ˆ",
                command=dialog.destroy,
                bg="#4c5052",
                fg="white",
                activebackground="#5c6062",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL
            )
            cancel_btn.pack(side="left", padx=5)
            
            # ç»‘å®šå›è½¦é”®
            entry.bind('<Return>', lambda e: confirm_rename())
            entry.bind('<Escape>', lambda e: dialog.destroy())
            
            # è®¾ç½®æ¨¡æ€å¯¹è¯æ¡†
            dialog.grab_set()
            dialog.focus_set()
            
        except Exception as e:
            print(f"æ˜¾ç¤ºé‡å‘½åå¯¹è¯æ¡†å¤±è´¥: {e}")
            self._show_message("æ— æ³•æ‰“å¼€é‡å‘½åå¯¹è¯æ¡†!")

    def _rename_shortcut(self, old_name, new_name):
        """é‡å‘½åå¿«æ·æ–¹å¼"""
        try:
            if new_name in self.paths_data:
                self._show_message("åç§°å·²å­˜åœ¨!", important=True)
                return
                
            # è·å–æ‰€æœ‰é¡¹ç›®çš„é¡ºåº
            items = list(self.paths_data.items())
            
            # æ‰¾åˆ°è¦é‡å‘½åé¡¹ç›®çš„ç´¢å¼•
            old_index = next(i for i, (name, _) in enumerate(items) if name == old_name)
            
            # è·å–åŸå§‹æ•°æ®
            path_data = self.paths_data[old_name]
            
            # åˆ›å»ºæ–°çš„æœ‰åºå­—å…¸ï¼Œä¿æŒåŸæœ‰é¡ºåº
            new_paths_data = {}
            
            # é‡å»ºå­—å…¸ï¼Œä¿æŒé¡ºåº
            for i, (name, data) in enumerate(items):
                if i == old_index:
                    # åœ¨åŸä½ç½®æ’å…¥æ–°åç§°
                    new_paths_data[new_name] = path_data
                else:
                    new_paths_data[name] = data
                    
            # æ›´æ–°æ•°æ®
            self.paths_data = new_paths_data
            
            # ä¿å­˜æ›´æ”¹
            self._save_paths()
            
            # é‡æ–°åˆ›å»ºæŒ‰é’®
            self._create_path_buttons()
            
            # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            self._show_message("é‡å‘½åæˆåŠŸ!", important=True)
            
        except Exception as e:
            print(f"é‡å‘½åå¤±è´¥: {e}")
            self._show_message("é‡å‘½åå¤±è´¥!", important=True)

    def _show_sort_dialog(self):
        """æ˜¾ç¤ºæ’åºé€‰é¡¹å¯¹è¯æ¡†"""
        try:
            dialog = tk.Toplevel(self.root)
            dialog.title("æ’åºé€‰é¡¹")
            dialog.configure(bg="#2b2b2b")
            dialog.transient(self.root)
            dialog.iconbitmap(self.icon_path)  # è®¾ç½®æ’åºå¯¹è¯æ¡†å›¾æ ‡
            
            # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
            window_width = 200
            window_height = 180
            x = self.root.winfo_x() + (self.root.winfo_width() - window_width) // 2
            y = self.root.winfo_y() + (self.root.winfo_height() - window_height) // 2
            dialog.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # åˆ›å»ºä¸»æ¡†æ¶
            frame = tk.Frame(dialog, bg="#2b2b2b", padx=20, pady=10)
            frame.pack(fill="both", expand=True)
            
            # æ·»åŠ æ ‡é¢˜
            title = tk.Label(
                frame,
                text="é€‰æ‹©æ’åºæ–¹å¼",
                bg="#2b2b2b",
                fg="white",
                font=self.FONT_TITLE
            )
            title.pack(pady=(0, 10))
            
            # åˆ›å»ºæ’åºé€‰é¡¹æŒ‰é’®
            def create_sort_button(text, sort_method):
                btn = tk.Button(
                    frame,
                    text=text,
                    command=lambda: [sort_method(), dialog.destroy()],
                    bg="#4c5052",
                    fg="white",
                    activebackground="#5c6062",
                    activeforeground="white",
                    relief="flat",
                    cursor="hand2",
                    font=self.FONT_NORMAL,
                    width=15
                )
                btn.pack(pady=5)
                return btn
            
            # æ·»åŠ æ’åºæŒ‰é’®
            create_sort_button("æŒ‰åç§°å‡åº", lambda: self._sort_buttons("name", reverse=False))
            create_sort_button("æŒ‰åç§°é™åº", lambda: self._sort_buttons("name", reverse=True))
            create_sort_button("æŒ‰ç±»å‹æ’åº", lambda: self._sort_buttons("type", reverse=False))
            
            # å–æ¶ˆæŒ‰é’®
            cancel_btn = tk.Button(
                frame,
                text="å–æ¶ˆ",
                command=dialog.destroy,
                bg="#B85959",
                fg="white",
                activebackground="#C86666",
                activeforeground="white",
                relief="flat",
                cursor="hand2",
                font=self.FONT_NORMAL,
                width=15
            )
            cancel_btn.pack(pady=10)
            
            # è®¾ç½®æ¨¡æ€å¯¹è¯æ¡†
            dialog.grab_set()
            dialog.focus_set()
            
        except Exception as e:
            print(f"æ˜¾ç¤ºæ’åºå¯¹è¯æ¡†å¤±è´¥: {e}")
            self._show_message("æ— æ³•æ‰“å¼€æ’åºå¯¹è¯æ¡†!")

    def _sort_buttons(self, sort_by="name", reverse=False):
        """æ’åºæŒ‰é’®"""
        try:
            if sort_by == "name":
                # æŒ‰åç§°æ’åº
                sorted_items = sorted(
                    self.paths_data.items(),
                    key=lambda x: x[0].lower(),
                    reverse=reverse
                )
            elif sort_by == "type":
                # æŒ‰ç±»å‹æ’åº
                def get_type_priority(path):
                    if path.startswith("folder:") or not any(path.startswith(p) for p in ["web:", "program:", "file:"]):
                        return 0  # æ–‡ä»¶å¤¹ä¼˜å…ˆ
                    elif path.startswith("program:"):
                        return 1  # ç¨‹åºæ¬¡ä¹‹
                    elif path.startswith("file:"):
                        try:
                            file_info = json.loads(path[5:])
                            type_priorities = {
                                "å·¥ç¨‹æ–‡ä»¶": 2,  # å·¥ç¨‹æ–‡ä»¶ä¼˜å…ˆçº§æé«˜
                                "å›¾ç‰‡": 3,
                                "è§†é¢‘": 4,
                                "éŸ³é¢‘": 5,
                                "æ–‡æ¡£": 6,
                                "ä»£ç ": 7,
                                "å‹ç¼©åŒ…": 8
                            }
                            return type_priorities.get(file_info['type'], 9)
                        except:
                            return 9
                    elif path.startswith("web:"):
                        return 10
                    return 11
                
                sorted_items = sorted(
                    self.paths_data.items(),
                    key=lambda x: (get_type_priority(x[1]), x[0].lower())
                )
            
            # æ›´æ–°æ’åºåçš„æ•°æ®
            self.paths_data = dict(sorted_items)
            
            # ä¿å­˜æ–°çš„é¡ºåº
            self._save_paths()
            
            # é‡æ–°åˆ›å»ºæŒ‰é’®
            self._create_path_buttons()
            
            # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            self._show_message("æ’åºå®Œæˆ!")
            
        except Exception as e:
            print(f"æ’åºå¤±è´¥: {e}")
            self._show_message("æ’åºå¤±è´¥!", important=True)  # é”™è¯¯ä¿¡æ¯æ˜¾ç¤ºçª—å£

    def _change_button_color(self, name, colors):
        """æ›´æ”¹æŒ‰é’®é¢œè‰²"""
        try:
            if not self.root.winfo_exists():
                print("ä¸»çª—å£å·²å…³é—­")
                return
            
            if name not in self.paths_data:
                print(f"æ‰¾ä¸åˆ°æŒ‰é’®: {name}")
                return
            
            path_data = self.paths_data[name]
            original_data = self.paths_data.copy()  # å¤‡ä»½åŸå§‹æ•°æ®
            
            # æ£€æŸ¥é¢œè‰²æ•°æ®çš„æœ‰æ•ˆæ€§
            if not isinstance(colors, dict) or 'bg' not in colors or 'active_bg' not in colors:
                print(f"æ— æ•ˆçš„é¢œè‰²æ•°æ®: {colors}")
                return
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯ç›´æ¥çš„æ–‡ä»¶å¤¹è·¯å¾„
            if not isinstance(path_data, str):
                print(f"æ— æ•ˆçš„è·¯å¾„æ•°æ®ç±»å‹: {type(path_data)}")
                return
            
            try:
                if not path_data.startswith(('program:', 'file:', 'web:', 'folder:')):
                    # å¦‚æœæ˜¯ç›´æ¥çš„æ–‡ä»¶å¤¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºfolderæ ¼å¼
                    folder_info = {
                        'path': path_data,
                        'colors': colors,
                        'type': 'folder'
                    }
                    new_data = f"folder:{json.dumps(folder_info, ensure_ascii=False)}"
                else:
                    # å¯¹äºå…¶ä»–ç±»å‹çš„è·¯å¾„ï¼Œè§£æå¹¶æ›´æ–°é¢œè‰²
                    prefix, data = path_data.split(':', 1)
                    info = json.loads(data)
                    
                    if not isinstance(info, dict):
                        raise ValueError(f"æ— æ•ˆçš„JSONæ•°æ®æ ¼å¼: {info}")
                    
                    # ä¿ç•™åŸæœ‰çš„æ‰€æœ‰ä¿¡æ¯ï¼Œåªæ›´æ–°é¢œè‰²
                    info['colors'] = colors
                    if 'type' not in info:
                        info['type'] = prefix
                    
                    new_data = f"{prefix}:{json.dumps(info, ensure_ascii=False)}"
                    
                # å…ˆå°è¯•éªŒè¯æ–°æ•°æ®çš„æœ‰æ•ˆæ€§
                if ':' in new_data:
                    prefix, json_str = new_data.split(':', 1)
                    json.loads(json_str)  # éªŒè¯JSON
                
                # æ›´æ–°æ•°æ®
                self.paths_data[name] = new_data
                
                # ä¿å­˜æ›´æ”¹
                try:
                    self._save_paths()
                except Exception as e:
                    print(f"ä¿å­˜è·¯å¾„å¤±è´¥: {e}")
                    self.paths_data = original_data  # æ¢å¤åŸå§‹æ•°æ®
                    raise
                
                # å®‰å…¨åœ°æ›´æ–°ç•Œé¢
                def safe_update():
                    if not self.root.winfo_exists():
                        return
                    try:
                        self._create_path_buttons()
                        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
                        self._show_message("é¢œè‰²å·²æ›´æ–°!")
                    except Exception as e:
                        print(f"æ›´æ–°ç•Œé¢å¤±è´¥: {e}")
                        self.paths_data = original_data  # æ¢å¤åŸå§‹æ•°æ®
                        self.root.after(100, self._create_path_buttons)
                
                # ä½¿ç”¨afteræ–¹æ³•ç¡®ä¿åœ¨ä¸»çº¿ç¨‹ä¸­æ›´æ–°UI
                self.root.after(10, safe_update)
                
            except Exception as e:
                print(f"å¤„ç†é¢œè‰²æ›´æ”¹å¤±è´¥: {e}")
                self.paths_data = original_data  # æ¢å¤åŸå§‹æ•°æ®
                self._show_message("æ›´æ”¹é¢œè‰²å¤±è´¥!")
                # å°è¯•æ¢å¤ç•Œé¢
                if self.root.winfo_exists():
                    self.root.after(100, self._create_path_buttons)
                
        except Exception as e:
            print(f"æ›´æ”¹æŒ‰é’®é¢œè‰²æ—¶å‡ºé”™: {e}")
            if hasattr(self, 'paths_data') and 'original_data' in locals():
                self.paths_data = original_data  # ç¡®ä¿æ¢å¤åŸå§‹æ•°æ®
            self._show_message("æ›´æ”¹é¢œè‰²å¤±è´¥!")
            # æœ€åçš„ç•Œé¢æ¢å¤å°è¯•
            if hasattr(self, 'root') and self.root.winfo_exists():
                self.root.after(100, self._create_path_buttons)

    def _validate_paths_data(self):
        """éªŒè¯è·¯å¾„æ•°æ®çš„å®Œæ•´æ€§"""
        try:
            for name, path_data in self.paths_data.items():
                if isinstance(path_data, str):
                    if path_data.startswith(('program:', 'file:', 'web:', 'folder:')):
                        prefix, data_str = path_data.split(':', 1)
                        # éªŒè¯JSONæ•°æ®
                        json.loads(data_str)
            return True
        except:
            return False

    def _safe_update_buttons(self):
        """å®‰å…¨åœ°æ›´æ–°æŒ‰é’®"""
        try:
            if self.root.winfo_exists():
                self._create_path_buttons()
                self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        except Exception as e:
            print(f"æ›´æ–°æŒ‰é’®å¤±è´¥: {e}")

    def _delayed_layout_update(self):
        """å»¶è¿Ÿæ›´æ–°å¸ƒå±€"""
        try:
            # å¼ºåˆ¶æ›´æ–°æ‰€æœ‰æ§ä»¶çš„å¸ƒå±€
            self.root.update_idletasks()
            self.main_frame.update_idletasks()
            self.buttons_frame.update_idletasks()
            self.canvas.update_idletasks()
            
            # ç¡®ä¿ç”»å¸ƒå®½åº¦æ­£ç¡®
            self.canvas.itemconfig(self.canvas_frame, width=self.canvas.winfo_width())
            
            # é‡æ–°åˆ›å»ºæŒ‰é’®
            self._create_path_buttons()
            
            # æ›´æ–°æ»šåŠ¨åŒºåŸŸ
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        except Exception as e:
            print(f"å»¶è¿Ÿå¸ƒå±€æ›´æ–°å¤±è´¥: {e}")

class ShortcutManager:
    def __init__(self):
        self.shortcuts = {}
        self.tags = set()
        
    def add_shortcut(self, name, path, tags=None):
        self.shortcuts[name] = {
            'path': path,
            'tags': set(tags or [])
        }
        if tags:
            self.tags.update(tags)

if __name__ == "__main__":
    app = FolderAccessTool()
    app.run()
